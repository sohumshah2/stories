"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-from-markdown";
exports.ids = ["vendor-chunks/mdast-util-from-markdown"];
exports.modules = {

/***/ "(ssr)/./node_modules/mdast-util-from-markdown/dev/lib/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-from-markdown/dev/lib/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromMarkdown: () => (/* binding */ fromMarkdown)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var mdast_util_to_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! mdast-util-to-string */ \"(ssr)/./node_modules/mdast-util-to-string/lib/index.js\");\n/* harmony import */ var micromark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark */ \"(ssr)/./node_modules/micromark/dev/lib/postprocess.js\");\n/* harmony import */ var micromark__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark */ \"(ssr)/./node_modules/micromark/dev/lib/parse.js\");\n/* harmony import */ var micromark__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark */ \"(ssr)/./node_modules/micromark/dev/lib/preprocess.js\");\n/* harmony import */ var micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! micromark-util-decode-numeric-character-reference */ \"(ssr)/./node_modules/micromark-util-decode-numeric-character-reference/dev/index.js\");\n/* harmony import */ var micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! micromark-util-decode-string */ \"(ssr)/./node_modules/micromark-util-decode-string/dev/index.js\");\n/* harmony import */ var micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! micromark-util-normalize-identifier */ \"(ssr)/./node_modules/micromark-util-normalize-identifier/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/constants.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var decode_named_character_reference__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! decode-named-character-reference */ \"(ssr)/./node_modules/decode-named-character-reference/index.js\");\n/* harmony import */ var unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-stringify-position */ \"(ssr)/./node_modules/unist-util-stringify-position/lib/index.js\");\n/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n *\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('../index.js').CompileData} CompileData\n */ /**\n * @typedef {Omit<Parent, 'children' | 'type'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */ /**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | null | undefined | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {undefined | void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {undefined}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {undefined}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isnâ€™t closed properly.\n */ /**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Fragment | Nodes>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {(this: CompileContext) => undefined} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {(this: CompileContext, node: Nodes, token: Token, onError?: OnEnterError) => undefined} enter\n *   Enter a node.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => undefined} exit\n *   Exit a node.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n * @property {CompileData} data\n *   Info passed around; key/value store.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */ \n\n\n\n\n\n\n\n\nconst own = {}.hasOwnProperty;\n/**\n * Turn markdown into a syntax tree.\n *\n * @overload\n * @param {Value} value\n * @param {Encoding | null | undefined} [encoding]\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @overload\n * @param {Value} value\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @param {Value} value\n *   Markdown to parse.\n * @param {Encoding | Options | null | undefined} [encoding]\n *   Character encoding for when `value` is `Buffer`.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Root}\n *   mdast tree.\n */ function fromMarkdown(value, encoding, options) {\n    if (typeof encoding !== \"string\") {\n        options = encoding;\n        encoding = undefined;\n    }\n    return compiler(options)((0,micromark__WEBPACK_IMPORTED_MODULE_0__.postprocess)((0,micromark__WEBPACK_IMPORTED_MODULE_1__.parse)(options).document().write((0,micromark__WEBPACK_IMPORTED_MODULE_2__.preprocess)()(value, encoding, true))));\n}\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */ function compiler(options) {\n    /** @type {Config} */ const config = {\n        transforms: [],\n        canContainEols: [\n            \"emphasis\",\n            \"fragment\",\n            \"heading\",\n            \"paragraph\",\n            \"strong\"\n        ],\n        enter: {\n            autolink: opener(link),\n            autolinkProtocol: onenterdata,\n            autolinkEmail: onenterdata,\n            atxHeading: opener(heading),\n            blockQuote: opener(blockQuote),\n            characterEscape: onenterdata,\n            characterReference: onenterdata,\n            codeFenced: opener(codeFlow),\n            codeFencedFenceInfo: buffer,\n            codeFencedFenceMeta: buffer,\n            codeIndented: opener(codeFlow, buffer),\n            codeText: opener(codeText, buffer),\n            codeTextData: onenterdata,\n            data: onenterdata,\n            codeFlowValue: onenterdata,\n            definition: opener(definition),\n            definitionDestinationString: buffer,\n            definitionLabelString: buffer,\n            definitionTitleString: buffer,\n            emphasis: opener(emphasis),\n            hardBreakEscape: opener(hardBreak),\n            hardBreakTrailing: opener(hardBreak),\n            htmlFlow: opener(html, buffer),\n            htmlFlowData: onenterdata,\n            htmlText: opener(html, buffer),\n            htmlTextData: onenterdata,\n            image: opener(image),\n            label: buffer,\n            link: opener(link),\n            listItem: opener(listItem),\n            listItemValue: onenterlistitemvalue,\n            listOrdered: opener(list, onenterlistordered),\n            listUnordered: opener(list),\n            paragraph: opener(paragraph),\n            reference: onenterreference,\n            referenceString: buffer,\n            resourceDestinationString: buffer,\n            resourceTitleString: buffer,\n            setextHeading: opener(heading),\n            strong: opener(strong),\n            thematicBreak: opener(thematicBreak)\n        },\n        exit: {\n            atxHeading: closer(),\n            atxHeadingSequence: onexitatxheadingsequence,\n            autolink: closer(),\n            autolinkEmail: onexitautolinkemail,\n            autolinkProtocol: onexitautolinkprotocol,\n            blockQuote: closer(),\n            characterEscapeValue: onexitdata,\n            characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n            characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n            characterReferenceValue: onexitcharacterreferencevalue,\n            codeFenced: closer(onexitcodefenced),\n            codeFencedFence: onexitcodefencedfence,\n            codeFencedFenceInfo: onexitcodefencedfenceinfo,\n            codeFencedFenceMeta: onexitcodefencedfencemeta,\n            codeFlowValue: onexitdata,\n            codeIndented: closer(onexitcodeindented),\n            codeText: closer(onexitcodetext),\n            codeTextData: onexitdata,\n            data: onexitdata,\n            definition: closer(),\n            definitionDestinationString: onexitdefinitiondestinationstring,\n            definitionLabelString: onexitdefinitionlabelstring,\n            definitionTitleString: onexitdefinitiontitlestring,\n            emphasis: closer(),\n            hardBreakEscape: closer(onexithardbreak),\n            hardBreakTrailing: closer(onexithardbreak),\n            htmlFlow: closer(onexithtmlflow),\n            htmlFlowData: onexitdata,\n            htmlText: closer(onexithtmltext),\n            htmlTextData: onexitdata,\n            image: closer(onexitimage),\n            label: onexitlabel,\n            labelText: onexitlabeltext,\n            lineEnding: onexitlineending,\n            link: closer(onexitlink),\n            listItem: closer(),\n            listOrdered: closer(),\n            listUnordered: closer(),\n            paragraph: closer(),\n            referenceString: onexitreferencestring,\n            resourceDestinationString: onexitresourcedestinationstring,\n            resourceTitleString: onexitresourcetitlestring,\n            resource: onexitresource,\n            setextHeading: closer(onexitsetextheading),\n            setextHeadingLineSequence: onexitsetextheadinglinesequence,\n            setextHeadingText: onexitsetextheadingtext,\n            strong: closer(),\n            thematicBreak: closer()\n        }\n    };\n    configure(config, (options || {}).mdastExtensions || []);\n    /** @type {CompileData} */ const data = {};\n    return compile;\n    /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */ function compile(events) {\n        /** @type {Root} */ let tree = {\n            type: \"root\",\n            children: []\n        };\n        /** @type {Omit<CompileContext, 'sliceSerialize'>} */ const context = {\n            stack: [\n                tree\n            ],\n            tokenStack: [],\n            config,\n            enter,\n            exit,\n            buffer,\n            resume,\n            data\n        };\n        /** @type {Array<number>} */ const listStack = [];\n        let index = -1;\n        while(++index < events.length){\n            // We preprocess lists to add `listItem` tokens, and to infer whether\n            // items the list itself are spread out.\n            if (events[index][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listOrdered || events[index][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listUnordered) {\n                if (events[index][0] === \"enter\") {\n                    listStack.push(index);\n                } else {\n                    const tail = listStack.pop();\n                    (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(typeof tail === \"number\", \"expected list ot be open\");\n                    index = prepareList(events, tail, index);\n                }\n            }\n        }\n        index = -1;\n        while(++index < events.length){\n            const handler = config[events[index][0]];\n            if (own.call(handler, events[index][1].type)) {\n                handler[events[index][1].type].call(Object.assign({\n                    sliceSerialize: events[index][2].sliceSerialize\n                }, context), events[index][1]);\n            }\n        }\n        // Handle tokens still being open.\n        if (context.tokenStack.length > 0) {\n            const tail = context.tokenStack[context.tokenStack.length - 1];\n            const handler = tail[1] || defaultOnError;\n            handler.call(context, undefined, tail[0]);\n        }\n        // Figure out `root` position.\n        tree.position = {\n            start: point(events.length > 0 ? events[0][1].start : {\n                line: 1,\n                column: 1,\n                offset: 0\n            }),\n            end: point(events.length > 0 ? events[events.length - 2][1].end : {\n                line: 1,\n                column: 1,\n                offset: 0\n            })\n        };\n        // Call transforms.\n        index = -1;\n        while(++index < config.transforms.length){\n            tree = config.transforms[index](tree) || tree;\n        }\n        return tree;\n    }\n    /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */ function prepareList(events, start, length) {\n        let index = start - 1;\n        let containerBalance = -1;\n        let listSpread = false;\n        /** @type {Token | undefined} */ let listItem;\n        /** @type {number | undefined} */ let lineIndex;\n        /** @type {number | undefined} */ let firstBlankLineIndex;\n        /** @type {boolean | undefined} */ let atMarker;\n        while(++index <= length){\n            const event = events[index];\n            switch(event[1].type){\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listUnordered:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listOrdered:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.blockQuote:\n                    {\n                        if (event[0] === \"enter\") {\n                            containerBalance++;\n                        } else {\n                            containerBalance--;\n                        }\n                        atMarker = undefined;\n                        break;\n                    }\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEndingBlank:\n                    {\n                        if (event[0] === \"enter\") {\n                            if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n                                firstBlankLineIndex = index;\n                            }\n                            atMarker = undefined;\n                        }\n                        break;\n                    }\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.linePrefix:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemValue:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemMarker:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemPrefix:\n                case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemPrefixWhitespace:\n                    {\n                        break;\n                    }\n                default:\n                    {\n                        atMarker = undefined;\n                    }\n            }\n            if (!containerBalance && event[0] === \"enter\" && event[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemPrefix || containerBalance === -1 && event[0] === \"exit\" && (event[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listUnordered || event[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listOrdered)) {\n                if (listItem) {\n                    let tailIndex = index;\n                    lineIndex = undefined;\n                    while(tailIndex--){\n                        const tailEvent = events[tailIndex];\n                        if (tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEndingBlank) {\n                            if (tailEvent[0] === \"exit\") continue;\n                            if (lineIndex) {\n                                events[lineIndex][1].type = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEndingBlank;\n                                listSpread = true;\n                            }\n                            tailEvent[1].type = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding;\n                            lineIndex = tailIndex;\n                        } else if (tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.linePrefix || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.blockQuotePrefix || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.blockQuotePrefixWhitespace || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.blockQuoteMarker || tailEvent[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemIndent) {\n                        // Empty\n                        } else {\n                            break;\n                        }\n                    }\n                    if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n                        listItem._spread = true;\n                    }\n                    // Fix position.\n                    listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n                    events.splice(lineIndex || index, 0, [\n                        \"exit\",\n                        listItem,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                }\n                // Create a new list item.\n                if (event[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.listItemPrefix) {\n                    /** @type {Token} */ const item = {\n                        type: \"listItem\",\n                        _spread: false,\n                        start: Object.assign({}, event[1].start),\n                        // @ts-expect-error: weâ€™ll add `end` in a second.\n                        end: undefined\n                    };\n                    listItem = item;\n                    events.splice(index, 0, [\n                        \"enter\",\n                        item,\n                        event[2]\n                    ]);\n                    index++;\n                    length++;\n                    firstBlankLineIndex = undefined;\n                    atMarker = true;\n                }\n            }\n        }\n        events[start][1]._spread = listSpread;\n        return length;\n    }\n    /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Nodes} create\n   *   Create a node.\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function opener(create, and) {\n        return open;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */ function open(token) {\n            enter.call(this, create(token), token);\n            if (and) and.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {undefined}\n   */ function buffer() {\n        this.stack.push({\n            type: \"fragment\",\n            children: []\n        });\n    }\n    /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Nodes} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {undefined}\n   *   Nothing.\n   */ function enter(node, token, errorHandler) {\n        const parent = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(parent, \"expected `parent`\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"children\" in parent, \"expected `parent`\");\n        /** @type {Array<Nodes>} */ const siblings = parent.children;\n        siblings.push(node);\n        this.stack.push(node);\n        this.tokenStack.push([\n            token,\n            errorHandler\n        ]);\n        node.position = {\n            start: point(token.start),\n            // @ts-expect-error: `end` will be patched later.\n            end: undefined\n        };\n    }\n    /**\n   * Create a closer handle.\n   *\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */ function closer(and) {\n        return close;\n        /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */ function close(token) {\n            if (and) and.call(this, token);\n            exit.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {undefined}\n   *   Nothing.\n   */ function exit(token, onExitError) {\n        const node = this.stack.pop();\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected `node`\");\n        const open = this.tokenStack.pop();\n        if (!open) {\n            throw new Error(\"Cannot close `\" + token.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n                start: token.start,\n                end: token.end\n            }) + \"): itâ€™s not open\");\n        } else if (open[0].type !== token.type) {\n            if (onExitError) {\n                onExitError.call(this, token, open[0]);\n            } else {\n                const handler = open[1] || defaultOnError;\n                handler.call(this, token, open[0]);\n            }\n        }\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type !== \"fragment\", \"unexpected fragment `exit`ed\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.position, \"expected `position` to be defined\");\n        node.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @returns {string}\n   */ function resume() {\n        return (0,mdast_util_to_string__WEBPACK_IMPORTED_MODULE_6__.toString)(this.stack.pop());\n    }\n    //\n    // Handlers.\n    //\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistordered() {\n        this.data.expectingFirstListItemValue = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterlistitemvalue(token) {\n        if (this.data.expectingFirstListItemValue) {\n            const ancestor = this.stack[this.stack.length - 2];\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(ancestor, \"expected nodes on stack\");\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(ancestor.type === \"list\", \"expected list on stack\");\n            ancestor.start = Number.parseInt(this.sliceSerialize(token), micromark_util_symbol__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseDecimal);\n            this.data.expectingFirstListItemValue = undefined;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfenceinfo() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.lang = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfencemeta() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.meta = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefencedfence() {\n        // Exit if this is the closing fence.\n        if (this.data.flowCodeInside) return;\n        this.buffer();\n        this.data.flowCodeInside = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodefenced() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, \"\");\n        this.data.flowCodeInside = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodeindented() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"code\", \"expected code on stack\");\n        node.value = data.replace(/(\\r?\\n|\\r)$/g, \"\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitionlabelstring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.label = label;\n        node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiontitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdefinitiondestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"definition\", \"expected definition on stack\");\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitatxheadingsequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"heading\", \"expected heading on stack\");\n        if (!node.depth) {\n            const depth = this.sliceSerialize(token).length;\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6, \"expected `depth` between `1` and `6`\");\n            node.depth = depth;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadingtext() {\n        this.data.setextHeadingSlurpLineEnding = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheadinglinesequence(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"heading\", \"expected heading on stack\");\n        node.depth = this.sliceSerialize(token).codePointAt(0) === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_9__.codes.equalsTo ? 1 : 2;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitsetextheading() {\n        this.data.setextHeadingSlurpLineEnding = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterdata(token) {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"children\" in node, \"expected parent on stack\");\n        /** @type {Array<Nodes>} */ const siblings = node.children;\n        let tail = siblings[siblings.length - 1];\n        if (!tail || tail.type !== \"text\") {\n            // Add a new text node.\n            tail = text();\n            tail.position = {\n                start: point(token.start),\n                // @ts-expect-error: weâ€™ll add `end` later.\n                end: undefined\n            };\n            siblings.push(tail);\n        }\n        this.stack.push(tail);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitdata(token) {\n        const tail = this.stack.pop();\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail, \"expected a `node` to be on the stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"value\" in tail, \"expected a `literal` to be on the stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail.position, \"expected `node` to have an open position\");\n        tail.value += this.sliceSerialize(token);\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlineending(token) {\n        const context = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(context, \"expected `node`\");\n        // If weâ€™re at a hard break, include the line ending in there.\n        if (this.data.atHardBreak) {\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"children\" in context, \"expected `parent`\");\n            const tail = context.children[context.children.length - 1];\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail.position, \"expected tail to have a starting position\");\n            tail.position.end = point(token.end);\n            this.data.atHardBreak = undefined;\n            return;\n        }\n        if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {\n            onenterdata.call(this, token);\n            onexitdata.call(this, token);\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithardbreak() {\n        this.data.atHardBreak = true;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmlflow() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"html\", \"expected html on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexithtmltext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"html\", \"expected html on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcodetext() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"inlineCode\", \"expected inline code on stack\");\n        node.value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlink() {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"link\", \"expected link on stack\");\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (this.data.inReference) {\n            /** @type {ReferenceType} */ const referenceType = this.data.referenceType || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        this.data.referenceType = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitimage() {\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\", \"expected image on stack\");\n        // Note: there are also `identifier` and `label` fields on this link node!\n        // These are used / cleaned here.\n        // To do: clean.\n        if (this.data.inReference) {\n            /** @type {ReferenceType} */ const referenceType = this.data.referenceType || \"shortcut\";\n            node.type += \"Reference\";\n            // @ts-expect-error: mutate.\n            node.referenceType = referenceType;\n            // @ts-expect-error: mutate.\n            delete node.url;\n            delete node.title;\n        } else {\n            // @ts-expect-error: mutate.\n            delete node.identifier;\n            // @ts-expect-error: mutate.\n            delete node.label;\n        }\n        this.data.referenceType = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabeltext(token) {\n        const string = this.sliceSerialize(token);\n        const ancestor = this.stack[this.stack.length - 2];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(ancestor, \"expected ancestor on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(ancestor.type === \"image\" || ancestor.type === \"link\", \"expected image or link on stack\");\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        ancestor.label = (0,micromark_util_decode_string__WEBPACK_IMPORTED_MODULE_10__.decodeString)(string);\n        // @ts-expect-error: same as above.\n        ancestor.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(string).toLowerCase();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitlabel() {\n        const fragment = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(fragment, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(fragment.type === \"fragment\", \"expected fragment on stack\");\n        const value = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        // Assume a reference.\n        this.data.inReference = true;\n        if (node.type === \"link\") {\n            /** @type {Array<PhrasingContent>} */ const children = fragment.children;\n            node.children = children;\n        } else {\n            node.alt = value;\n        }\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcedestinationstring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        node.url = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresourcetitlestring() {\n        const data = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image or link on stack\");\n        node.title = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitresource() {\n        this.data.inReference = undefined;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onenterreference() {\n        this.data.referenceType = \"collapsed\";\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitreferencestring(token) {\n        const label = this.resume();\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"image\" || node.type === \"link\", \"expected image reference or link reference on stack\");\n        // @ts-expect-error: stash this on the node, as it might become a reference\n        // later.\n        node.label = label;\n        // @ts-expect-error: same as above.\n        node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_8__.normalizeIdentifier)(this.sliceSerialize(token)).toLowerCase();\n        this.data.referenceType = \"full\";\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencemarker(token) {\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(token.type === \"characterReferenceMarkerNumeric\" || token.type === \"characterReferenceMarkerHexadecimal\");\n        this.data.characterReferenceType = token.type;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitcharacterreferencevalue(token) {\n        const data = this.sliceSerialize(token);\n        const type = this.data.characterReferenceType;\n        /** @type {string} */ let value;\n        if (type) {\n            value = (0,micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_11__.decodeNumericCharacterReference)(data, type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.characterReferenceMarkerNumeric ? micromark_util_symbol__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseDecimal : micromark_util_symbol__WEBPACK_IMPORTED_MODULE_7__.constants.numericBaseHexadecimal);\n            this.data.characterReferenceType = undefined;\n        } else {\n            const result = (0,decode_named_character_reference__WEBPACK_IMPORTED_MODULE_12__.decodeNamedCharacterReference)(data);\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(result !== false, \"expected reference to decode\");\n            value = result;\n        }\n        const tail = this.stack.pop();\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail, \"expected `node`\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(tail.position, \"expected `node.position`\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(\"value\" in tail, \"expected `node.value`\");\n        tail.value += value;\n        tail.position.end = point(token.end);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkprotocol(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"link\", \"expected link on stack\");\n        node.url = this.sliceSerialize(token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */ function onexitautolinkemail(token) {\n        onexitdata.call(this, token);\n        const node = this.stack[this.stack.length - 1];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node, \"expected node on stack\");\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(node.type === \"link\", \"expected link on stack\");\n        node.url = \"mailto:\" + this.sliceSerialize(token);\n    }\n    //\n    // Creaters.\n    //\n    /** @returns {Blockquote} */ function blockQuote() {\n        return {\n            type: \"blockquote\",\n            children: []\n        };\n    }\n    /** @returns {Code} */ function codeFlow() {\n        return {\n            type: \"code\",\n            lang: null,\n            meta: null,\n            value: \"\"\n        };\n    }\n    /** @returns {InlineCode} */ function codeText() {\n        return {\n            type: \"inlineCode\",\n            value: \"\"\n        };\n    }\n    /** @returns {Definition} */ function definition() {\n        return {\n            type: \"definition\",\n            identifier: \"\",\n            label: null,\n            title: null,\n            url: \"\"\n        };\n    }\n    /** @returns {Emphasis} */ function emphasis() {\n        return {\n            type: \"emphasis\",\n            children: []\n        };\n    }\n    /** @returns {Heading} */ function heading() {\n        return {\n            type: \"heading\",\n            // @ts-expect-error `depth` will be set later.\n            depth: 0,\n            children: []\n        };\n    }\n    /** @returns {Break} */ function hardBreak() {\n        return {\n            type: \"break\"\n        };\n    }\n    /** @returns {Html} */ function html() {\n        return {\n            type: \"html\",\n            value: \"\"\n        };\n    }\n    /** @returns {Image} */ function image() {\n        return {\n            type: \"image\",\n            title: null,\n            url: \"\",\n            alt: null\n        };\n    }\n    /** @returns {Link} */ function link() {\n        return {\n            type: \"link\",\n            title: null,\n            url: \"\",\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {List}\n   */ function list(token) {\n        return {\n            type: \"list\",\n            ordered: token.type === \"listOrdered\",\n            start: null,\n            spread: token._spread,\n            children: []\n        };\n    }\n    /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */ function listItem(token) {\n        return {\n            type: \"listItem\",\n            spread: token._spread,\n            checked: null,\n            children: []\n        };\n    }\n    /** @returns {Paragraph} */ function paragraph() {\n        return {\n            type: \"paragraph\",\n            children: []\n        };\n    }\n    /** @returns {Strong} */ function strong() {\n        return {\n            type: \"strong\",\n            children: []\n        };\n    }\n    /** @returns {Text} */ function text() {\n        return {\n            type: \"text\",\n            value: \"\"\n        };\n    }\n    /** @returns {ThematicBreak} */ function thematicBreak() {\n        return {\n            type: \"thematicBreak\"\n        };\n    }\n}\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */ function point(d) {\n    return {\n        line: d.line,\n        column: d.column,\n        offset: d.offset\n    };\n}\n/**\n * @param {Config} combined\n * @param {Array<Array<Extension> | Extension>} extensions\n * @returns {undefined}\n */ function configure(combined, extensions) {\n    let index = -1;\n    while(++index < extensions.length){\n        const value = extensions[index];\n        if (Array.isArray(value)) {\n            configure(combined, value);\n        } else {\n            extension(combined, value);\n        }\n    }\n}\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {undefined}\n */ function extension(combined, extension) {\n    /** @type {keyof Extension} */ let key;\n    for(key in extension){\n        if (own.call(extension, key)) {\n            switch(key){\n                case \"canContainEols\":\n                    {\n                        const right = extension[key];\n                        if (right) {\n                            combined[key].push(...right);\n                        }\n                        break;\n                    }\n                case \"transforms\":\n                    {\n                        const right = extension[key];\n                        if (right) {\n                            combined[key].push(...right);\n                        }\n                        break;\n                    }\n                case \"enter\":\n                case \"exit\":\n                    {\n                        const right = extension[key];\n                        if (right) {\n                            Object.assign(combined[key], right);\n                        }\n                        break;\n                    }\n            }\n        }\n    }\n}\n/** @type {OnEnterError} */ function defaultOnError(left, right) {\n    if (left) {\n        throw new Error(\"Cannot close `\" + left.type + \"` (\" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: left.start,\n            end: left.end\n        }) + \"): a different token (`\" + right.type + \"`, \" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: right.start,\n            end: right.end\n        }) + \") is open\");\n    } else {\n        throw new Error(\"Cannot close document, a token (`\" + right.type + \"`, \" + (0,unist_util_stringify_position__WEBPACK_IMPORTED_MODULE_5__.stringifyPosition)({\n            start: right.start,\n            end: right.end\n        }) + \") is still open\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duL2Rldi9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUNDLEdBRUQ7O0NBRUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0ErQ0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkNDLEdBRWtDO0FBQ1U7QUFDVztBQUN5QztBQUN4QztBQUNjO0FBQ1Y7QUFDaUI7QUFDZjtBQUUvRCxNQUFNYyxNQUFNLENBQUMsRUFBRUMsY0FBYztBQUU3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNNLFNBQVNDLGFBQWFDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxPQUFPO0lBQ25ELElBQUksT0FBT0QsYUFBYSxVQUFVO1FBQ2hDQyxVQUFVRDtRQUNWQSxXQUFXRTtJQUNiO0lBRUEsT0FBT0MsU0FBU0YsU0FDZGYsc0RBQVdBLENBQ1RELGdEQUFLQSxDQUFDZ0IsU0FBU0csUUFBUSxHQUFHQyxLQUFLLENBQUNsQixxREFBVUEsR0FBR1ksT0FBT0MsVUFBVTtBQUdwRTtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTRyxTQUFTRixPQUFPO0lBQ3ZCLG1CQUFtQixHQUNuQixNQUFNSyxTQUFTO1FBQ2JDLFlBQVksRUFBRTtRQUNkQyxnQkFBZ0I7WUFBQztZQUFZO1lBQVk7WUFBVztZQUFhO1NBQVM7UUFDMUVDLE9BQU87WUFDTEMsVUFBVUMsT0FBT0M7WUFDakJDLGtCQUFrQkM7WUFDbEJDLGVBQWVEO1lBQ2ZFLFlBQVlMLE9BQU9NO1lBQ25CQyxZQUFZUCxPQUFPTztZQUNuQkMsaUJBQWlCTDtZQUNqQk0sb0JBQW9CTjtZQUNwQk8sWUFBWVYsT0FBT1c7WUFDbkJDLHFCQUFxQkM7WUFDckJDLHFCQUFx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UixzQ0FDRXVDLE1BQU0vRixJQUFJLEdBQ1YsUUFDQW5ILGdGQUFpQkEsQ0FBQztZQUFDdUksT0FBTzJFLE1BQU0zRSxLQUFLO1lBQUVLLEtBQUtzRSxNQUFNdEUsR0FBRztRQUFBLEtBQ3JEO0lBRU47QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0b3JpZXMvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duL2Rldi9saWIvaW5kZXguanM/YmViNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQnJlYWt9IEJyZWFrXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkJsb2NrcXVvdGV9IEJsb2NrcXVvdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuQ29kZX0gQ29kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5EZWZpbml0aW9ufSBEZWZpbml0aW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkVtcGhhc2lzfSBFbXBoYXNpc1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5IZWFkaW5nfSBIZWFkaW5nXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkh0bWx9IEh0bWxcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSW1hZ2V9IEltYWdlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLklubGluZUNvZGV9IElubGluZUNvZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuTGlua30gTGlua1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5MaXN0fSBMaXN0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLkxpc3RJdGVtfSBMaXN0SXRlbVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Ob2Rlc30gTm9kZXNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuUGFyYWdyYXBofSBQYXJhZ3JhcGhcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuUGFyZW50fSBQYXJlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuUGhyYXNpbmdDb250ZW50fSBQaHJhc2luZ0NvbnRlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuUmVmZXJlbmNlVHlwZX0gUmVmZXJlbmNlVHlwZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Sb290fSBSb290XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlN0cm9uZ30gU3Ryb25nXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlRleHR9IFRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuVGhlbWF0aWNCcmVha30gVGhlbWF0aWNCcmVha1xuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuRW5jb2Rpbmd9IEVuY29kaW5nXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV2ZW50fSBFdmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5QYXJzZU9wdGlvbnN9IFBhcnNlT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLXV0aWwtdHlwZXMnKS5Ub2tlbn0gVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW5pemVDb250ZXh0fSBUb2tlbml6ZUNvbnRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVmFsdWV9IFZhbHVlXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5Qb2ludH0gUG9pbnRcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9pbmRleC5qcycpLkNvbXBpbGVEYXRhfSBDb21waWxlRGF0YVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09taXQ8UGFyZW50LCAnY2hpbGRyZW4nIHwgJ3R5cGUnPiAmIHt0eXBlOiAnZnJhZ21lbnQnLCBjaGlsZHJlbjogQXJyYXk8UGhyYXNpbmdDb250ZW50Pn19IEZyYWdtZW50XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgVHJhbnNmb3JtXG4gKiAgIEV4dHJhIHRyYW5zZm9ybSwgdG8gY2hhbmdlIHRoZSBBU1QgYWZ0ZXJ3YXJkcy5cbiAqIEBwYXJhbSB7Um9vdH0gdHJlZVxuICogICBUcmVlIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtSb290IHwgbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWR9XG4gKiAgIE5ldyB0cmVlIG9yIG5vdGhpbmcgKGluIHdoaWNoIGNhc2UgdGhlIGN1cnJlbnQgdHJlZSBpcyB1c2VkKS5cbiAqXG4gKiBAY2FsbGJhY2sgSGFuZGxlXG4gKiAgIEhhbmRsZSBhIHRva2VuLlxuICogQHBhcmFtIHtDb21waWxlQ29udGV4dH0gdGhpc1xuICogICBDb250ZXh0LlxuICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAqICAgQ3VycmVudCB0b2tlbi5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWQgfCB2b2lkfVxuICogICBOb3RoaW5nLlxuICpcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8c3RyaW5nLCBIYW5kbGU+fSBIYW5kbGVzXG4gKiAgIFRva2VuIHR5cGVzIG1hcHBpbmcgdG8gaGFuZGxlc1xuICpcbiAqIEBjYWxsYmFjayBPbkVudGVyRXJyb3JcbiAqICAgSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBgcmlnaHRgIHRva2VuIGlzIG9wZW4sIGJ1dCBpdCBpcyBjbG9zZWQgKGJ5IHRoZVxuICogICBgbGVmdGAgdG9rZW4pIG9yIGJlY2F1c2Ugd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAqIEBwYXJhbSB7T21pdDxDb21waWxlQ29udGV4dCwgJ3NsaWNlU2VyaWFsaXplJz59IHRoaXNcbiAqICAgQ29udGV4dC5cbiAqIEBwYXJhbSB7VG9rZW4gfCB1bmRlZmluZWR9IGxlZnRcbiAqICAgTGVmdCB0b2tlbi5cbiAqIEBwYXJhbSB7VG9rZW59IHJpZ2h0XG4gKiAgIFJpZ2h0IHRva2VuLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqXG4gKiBAY2FsbGJhY2sgT25FeGl0RXJyb3JcbiAqICAgSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBgcmlnaHRgIHRva2VuIGlzIG9wZW4gYnV0IGl0IGlzIGNsb3NlZCBieVxuICogICBleGl0aW5nIHRoZSBgbGVmdGAgdG9rZW4uXG4gKiBAcGFyYW0ge09taXQ8Q29tcGlsZUNvbnRleHQsICdzbGljZVNlcmlhbGl6ZSc+fSB0aGlzXG4gKiAgIENvbnRleHQuXG4gKiBAcGFyYW0ge1Rva2VufSBsZWZ0XG4gKiAgIExlZnQgdG9rZW4uXG4gKiBAcGFyYW0ge1Rva2VufSByaWdodFxuICogICBSaWdodCB0b2tlbi5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKlxuICogQHR5cGVkZWYge1tUb2tlbiwgT25FbnRlckVycm9yIHwgdW5kZWZpbmVkXX0gVG9rZW5UdXBsZVxuICogICBPcGVuIHRva2VuIG9uIHRoZSBzdGFjaywgd2l0aCBhbiBvcHRpb25hbCBlcnJvciBoYW5kbGVyIGZvciB3aGVuXG4gKiAgIHRoYXQgdG9rZW4gaXNu4oCZdCBjbG9zZWQgcHJvcGVybHkuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBDb25maWdcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqXG4gKiAgIFdlIGhhdmUgb3VyIGRlZmF1bHRzLCBidXQgZXh0ZW5zaW9ucyB3aWxsIGFkZCBtb3JlLlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBjYW5Db250YWluRW9sc1xuICogICBUb2tlbiB0eXBlcyB3aGVyZSBsaW5lIGVuZGluZ3MgYXJlIHVzZWQuXG4gKiBAcHJvcGVydHkge0hhbmRsZXN9IGVudGVyXG4gKiAgIE9wZW5pbmcgaGFuZGxlcy5cbiAqIEBwcm9wZXJ0eSB7SGFuZGxlc30gZXhpdFxuICogICBDbG9zaW5nIGhhbmRsZXMuXG4gKiBAcHJvcGVydHkge0FycmF5PFRyYW5zZm9ybT59IHRyYW5zZm9ybXNcbiAqICAgVHJlZSB0cmFuc2Zvcm1zLlxuICpcbiAqIEB0eXBlZGVmIHtQYXJ0aWFsPENvbmZpZz59IEV4dGVuc2lvblxuICogICBDaGFuZ2UgaG93IG1hcmtkb3duIHRva2VucyBmcm9tIG1pY3JvbWFyayBhcmUgdHVybmVkIGludG8gbWRhc3QuXG4gKlxuICogQHR5cGVkZWYgQ29tcGlsZUNvbnRleHRcbiAqICAgbWRhc3QgY29tcGlsZXIgY29udGV4dC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8RnJhZ21lbnQgfCBOb2Rlcz59IHN0YWNrXG4gKiAgIFN0YWNrIG9mIG5vZGVzLlxuICogQHByb3BlcnR5IHtBcnJheTxUb2tlblR1cGxlPn0gdG9rZW5TdGFja1xuICogICBTdGFjayBvZiB0b2tlbnMuXG4gKiBAcHJvcGVydHkgeyh0aGlzOiBDb21waWxlQ29udGV4dCkgPT4gdW5kZWZpbmVkfSBidWZmZXJcbiAqICAgQ2FwdHVyZSBzb21lIG9mIHRoZSBvdXRwdXQgZGF0YS5cbiAqIEBwcm9wZXJ0eSB7KHRoaXM6IENvbXBpbGVDb250ZXh0KSA9PiBzdHJpbmd9IHJlc3VtZVxuICogICBTdG9wIGNhcHR1cmluZyBhbmQgYWNjZXNzIHRoZSBvdXRwdXQgZGF0YS5cbiAqIEBwcm9wZXJ0eSB7KHRoaXM6IENvbXBpbGVDb250ZXh0LCBub2RlOiBOb2RlcywgdG9rZW46IFRva2VuLCBvbkVycm9yPzogT25FbnRlckVycm9yKSA9PiB1bmRlZmluZWR9IGVudGVyXG4gKiAgIEVudGVyIGEgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7KHRoaXM6IENvbXBpbGVDb250ZXh0LCB0b2tlbjogVG9rZW4sIG9uRXJyb3I/OiBPbkV4aXRFcnJvcikgPT4gdW5kZWZpbmVkfSBleGl0XG4gKiAgIEV4aXQgYSBub2RlLlxuICogQHByb3BlcnR5IHtUb2tlbml6ZUNvbnRleHRbJ3NsaWNlU2VyaWFsaXplJ119IHNsaWNlU2VyaWFsaXplXG4gKiAgIEdldCB0aGUgc3RyaW5nIHZhbHVlIG9mIGEgdG9rZW4uXG4gKiBAcHJvcGVydHkge0NvbmZpZ30gY29uZmlnXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkge0NvbXBpbGVEYXRhfSBkYXRhXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZDsga2V5L3ZhbHVlIHN0b3JlLlxuICpcbiAqIEB0eXBlZGVmIEZyb21NYXJrZG93bk9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiBmb3IgaG93IHRvIGJ1aWxkIG1kYXN0LlxuICogQHByb3BlcnR5IHtBcnJheTxFeHRlbnNpb24gfCBBcnJheTxFeHRlbnNpb24+PiB8IG51bGwgfCB1bmRlZmluZWR9IFttZGFzdEV4dGVuc2lvbnNdXG4gKiAgIEV4dGVuc2lvbnMgZm9yIHRoaXMgdXRpbGl0eSB0byBjaGFuZ2UgaG93IHRva2VucyBhcmUgdHVybmVkIGludG8gYSB0cmVlLlxuICpcbiAqIEB0eXBlZGVmIHtQYXJzZU9wdGlvbnMgJiBGcm9tTWFya2Rvd25PcHRpb25zfSBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKi9cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCB7dG9TdHJpbmd9IGZyb20gJ21kYXN0LXV0aWwtdG8tc3RyaW5nJ1xuaW1wb3J0IHtwYXJzZSwgcG9zdHByb2Nlc3MsIHByZXByb2Nlc3N9IGZyb20gJ21pY3JvbWFyaydcbmltcG9ydCB7ZGVjb2RlTnVtZXJpY0NoYXJhY3RlclJlZmVyZW5jZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtZGVjb2RlLW51bWVyaWMtY2hhcmFjdGVyLXJlZmVyZW5jZSdcbmltcG9ydCB7ZGVjb2RlU3RyaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1kZWNvZGUtc3RyaW5nJ1xuaW1wb3J0IHtub3JtYWxpemVJZGVudGlmaWVyfSBmcm9tICdtaWNyb21hcmstdXRpbC1ub3JtYWxpemUtaWRlbnRpZmllcidcbmltcG9ydCB7Y29kZXMsIGNvbnN0YW50cywgdHlwZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbCdcbmltcG9ydCB7ZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2V9IGZyb20gJ2RlY29kZS1uYW1lZC1jaGFyYWN0ZXItcmVmZXJlbmNlJ1xuaW1wb3J0IHtzdHJpbmdpZnlQb3NpdGlvbn0gZnJvbSAndW5pc3QtdXRpbC1zdHJpbmdpZnktcG9zaXRpb24nXG5cbmNvbnN0IG93biA9IHt9Lmhhc093blByb3BlcnR5XG5cbi8qKlxuICogVHVybiBtYXJrZG93biBpbnRvIGEgc3ludGF4IHRyZWUuXG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZVxuICogQHBhcmFtIHtFbmNvZGluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtlbmNvZGluZ11cbiAqIEBwYXJhbSB7T3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Jvb3R9XG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZVxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7Um9vdH1cbiAqXG4gKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZVxuICogICBNYXJrZG93biB0byBwYXJzZS5cbiAqIEBwYXJhbSB7RW5jb2RpbmcgfCBPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2VuY29kaW5nXVxuICogICBDaGFyYWN0ZXIgZW5jb2RpbmcgZm9yIHdoZW4gYHZhbHVlYCBpcyBgQnVmZmVyYC5cbiAqIEBwYXJhbSB7T3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICogICBDb25maWd1cmF0aW9uLlxuICogQHJldHVybnMge1Jvb3R9XG4gKiAgIG1kYXN0IHRyZWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWFya2Rvd24odmFsdWUsIGVuY29kaW5nLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHJldHVybiBjb21waWxlcihvcHRpb25zKShcbiAgICBwb3N0cHJvY2VzcyhcbiAgICAgIHBhcnNlKG9wdGlvbnMpLmRvY3VtZW50KCkud3JpdGUocHJlcHJvY2VzcygpKHZhbHVlLCBlbmNvZGluZywgdHJ1ZSkpXG4gICAgKVxuICApXG59XG5cbi8qKlxuICogTm90ZSB0aGlzIGNvbXBpbGVyIG9ubHkgdW5kZXJzdGFuZCBjb21wbGV0ZSBidWZmZXJpbmcsIG5vdCBzdHJlYW1pbmcuXG4gKlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVyKG9wdGlvbnMpIHtcbiAgLyoqIEB0eXBlIHtDb25maWd9ICovXG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICB0cmFuc2Zvcm1zOiBbXSxcbiAgICBjYW5Db250YWluRW9sczogWydlbXBoYXNpcycsICdmcmFnbWVudCcsICdoZWFkaW5nJywgJ3BhcmFncmFwaCcsICdzdHJvbmcnXSxcbiAgICBlbnRlcjoge1xuICAgICAgYXV0b2xpbms6IG9wZW5lcihsaW5rKSxcbiAgICAgIGF1dG9saW5rUHJvdG9jb2w6IG9uZW50ZXJkYXRhLFxuICAgICAgYXV0b2xpbmtFbWFpbDogb25lbnRlcmRhdGEsXG4gICAgICBhdHhIZWFkaW5nOiBvcGVuZXIoaGVhZGluZyksXG4gICAgICBibG9ja1F1b3RlOiBvcGVuZXIoYmxvY2tRdW90ZSksXG4gICAgICBjaGFyYWN0ZXJFc2NhcGU6IG9uZW50ZXJkYXRhLFxuICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlOiBvbmVudGVyZGF0YSxcbiAgICAgIGNvZGVGZW5jZWQ6IG9wZW5lcihjb2RlRmxvdyksXG4gICAgICBjb2RlRmVuY2VkRmVuY2VJbmZvOiBidWZmZXIsXG4gICAgICBjb2RlRmVuY2VkRmVuY2VNZXRhOiBidWZmZXIsXG4gICAgICBjb2RlSW5kZW50ZWQ6IG9wZW5lcihjb2RlRmxvdywgYnVmZmVyKSxcbiAgICAgIGNvZGVUZXh0OiBvcGVuZXIoY29kZVRleHQsIGJ1ZmZlciksXG4gICAgICBjb2RlVGV4dERhdGE6IG9uZW50ZXJkYXRhLFxuICAgICAgZGF0YTogb25lbnRlcmRhdGEsXG4gICAgICBjb2RlRmxvd1ZhbHVlOiBvbmVudGVyZGF0YSxcbiAgICAgIGRlZmluaXRpb246IG9wZW5lcihkZWZpbml0aW9uKSxcbiAgICAgIGRlZmluaXRpb25EZXN0aW5hdGlvblN0cmluZzogYnVmZmVyLFxuICAgICAgZGVmaW5pdGlvbkxhYmVsU3RyaW5nOiBidWZmZXIsXG4gICAgICBkZWZpbml0aW9uVGl0bGVTdHJpbmc6IGJ1ZmZlcixcbiAgICAgIGVtcGhhc2lzOiBvcGVuZXIoZW1waGFzaXMpLFxuICAgICAgaGFyZEJyZWFrRXNjYXBlOiBvcGVuZXIoaGFyZEJyZWFrKSxcbiAgICAgIGhhcmRCcmVha1RyYWlsaW5nOiBvcGVuZXIoaGFyZEJyZWFrKSxcbiAgICAgIGh0bWxGbG93OiBvcGVuZXIoaHRtbCwgYnVmZmVyKSxcbiAgICAgIGh0bWxGbG93RGF0YTogb25lbnRlcmRhdGEsXG4gICAgICBodG1sVGV4dDogb3BlbmVyKGh0bWwsIGJ1ZmZlciksXG4gICAgICBodG1sVGV4dERhdGE6IG9uZW50ZXJkYXRhLFxuICAgICAgaW1hZ2U6IG9wZW5lcihpbWFnZSksXG4gICAgICBsYWJlbDogYnVmZmVyLFxuICAgICAgbGluazogb3BlbmVyKGxpbmspLFxuICAgICAgbGlzdEl0ZW06IG9wZW5lcihsaXN0SXRlbSksXG4gICAgICBsaXN0SXRlbVZhbHVlOiBvbmVudGVybGlzdGl0ZW12YWx1ZSxcbiAgICAgIGxpc3RPcmRlcmVkOiBvcGVuZXIobGlzdCwgb25lbnRlcmxpc3RvcmRlcmVkKSxcbiAgICAgIGxpc3RVbm9yZGVyZWQ6IG9wZW5lcihsaXN0KSxcbiAgICAgIHBhcmFncmFwaDogb3BlbmVyKHBhcmFncmFwaCksXG4gICAgICByZWZlcmVuY2U6IG9uZW50ZXJyZWZlcmVuY2UsXG4gICAgICByZWZlcmVuY2VTdHJpbmc6IGJ1ZmZlcixcbiAgICAgIHJlc291cmNlRGVzdGluYXRpb25TdHJpbmc6IGJ1ZmZlcixcbiAgICAgIHJlc291cmNlVGl0bGVTdHJpbmc6IGJ1ZmZlcixcbiAgICAgIHNldGV4dEhlYWRpbmc6IG9wZW5lcihoZWFkaW5nKSxcbiAgICAgIHN0cm9uZzogb3BlbmVyKHN0cm9uZyksXG4gICAgICB0aGVtYXRpY0JyZWFrOiBvcGVuZXIodGhlbWF0aWNCcmVhaylcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIGF0eEhlYWRpbmc6IGNsb3NlcigpLFxuICAgICAgYXR4SGVhZGluZ1NlcXVlbmNlOiBvbmV4aXRhdHhoZWFkaW5nc2VxdWVuY2UsXG4gICAgICBhdXRvbGluazogY2xvc2VyKCksXG4gICAgICBhdXRvbGlua0VtYWlsOiBvbmV4aXRhdXRvbGlua2VtYWlsLFxuICAgICAgYXV0b2xpbmtQcm90b2NvbDogb25leGl0YXV0b2xpbmtwcm90b2NvbCxcbiAgICAgIGJsb2NrUXVvdGU6IGNsb3NlcigpLFxuICAgICAgY2hhcmFjdGVyRXNjYXBlVmFsdWU6IG9uZXhpdGRhdGEsXG4gICAgICBjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJIZXhhZGVjaW1hbDogb25leGl0Y2hhcmFjdGVycmVmZXJlbmNlbWFya2VyLFxuICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyTnVtZXJpYzogb25leGl0Y2hhcmFjdGVycmVmZXJlbmNlbWFya2VyLFxuICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWU6IG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZXZhbHVlLFxuICAgICAgY29kZUZlbmNlZDogY2xvc2VyKG9uZXhpdGNvZGVmZW5jZWQpLFxuICAgICAgY29kZUZlbmNlZEZlbmNlOiBvbmV4aXRjb2RlZmVuY2VkZmVuY2UsXG4gICAgICBjb2RlRmVuY2VkRmVuY2VJbmZvOiBvbmV4aXRjb2RlZmVuY2VkZmVuY2VpbmZvLFxuICAgICAgY29kZUZlbmNlZEZlbmNlTWV0YTogb25leGl0Y29kZWZlbmNlZGZlbmNlbWV0YSxcbiAgICAgIGNvZGVGbG93VmFsdWU6IG9uZXhpdGRhdGEsXG4gICAgICBjb2RlSW5kZW50ZWQ6IGNsb3NlcihvbmV4aXRjb2RlaW5kZW50ZWQpLFxuICAgICAgY29kZVRleHQ6IGNsb3NlcihvbmV4aXRjb2RldGV4dCksXG4gICAgICBjb2RlVGV4dERhdGE6IG9uZXhpdGRhdGEsXG4gICAgICBkYXRhOiBvbmV4aXRkYXRhLFxuICAgICAgZGVmaW5pdGlvbjogY2xvc2VyKCksXG4gICAgICBkZWZpbml0aW9uRGVzdGluYXRpb25TdHJpbmc6IG9uZXhpdGRlZmluaXRpb25kZXN0aW5hdGlvbnN0cmluZyxcbiAgICAgIGRlZmluaXRpb25MYWJlbFN0cmluZzogb25leGl0ZGVmaW5pdGlvbmxhYmVsc3RyaW5nLFxuICAgICAgZGVmaW5pdGlvblRpdGxlU3RyaW5nOiBvbmV4aXRkZWZpbml0aW9udGl0bGVzdHJpbmcsXG4gICAgICBlbXBoYXNpczogY2xvc2VyKCksXG4gICAgICBoYXJkQnJlYWtFc2NhcGU6IGNsb3NlcihvbmV4aXRoYXJkYnJlYWspLFxuICAgICAgaGFyZEJyZWFrVHJhaWxpbmc6IGNsb3NlcihvbmV4aXRoYXJkYnJlYWspLFxuICAgICAgaHRtbEZsb3c6IGNsb3NlcihvbmV4aXRodG1sZmxvdyksXG4gICAgICBodG1sRmxvd0RhdGE6IG9uZXhpdGRhdGEsXG4gICAgICBodG1sVGV4dDogY2xvc2VyKG9uZXhpdGh0bWx0ZXh0KSxcbiAgICAgIGh0bWxUZXh0RGF0YTogb25leGl0ZGF0YSxcbiAgICAgIGltYWdlOiBjbG9zZXIob25leGl0aW1hZ2UpLFxuICAgICAgbGFiZWw6IG9uZXhpdGxhYmVsLFxuICAgICAgbGFiZWxUZXh0OiBvbmV4aXRsYWJlbHRleHQsXG4gICAgICBsaW5lRW5kaW5nOiBvbmV4aXRsaW5lZW5kaW5nLFxuICAgICAgbGluazogY2xvc2VyKG9uZXhpdGxpbmspLFxuICAgICAgbGlzdEl0ZW06IGNsb3NlcigpLFxuICAgICAgbGlzdE9yZGVyZWQ6IGNsb3NlcigpLFxuICAgICAgbGlzdFVub3JkZXJlZDogY2xvc2VyKCksXG4gICAgICBwYXJhZ3JhcGg6IGNsb3NlcigpLFxuICAgICAgcmVmZXJlbmNlU3RyaW5nOiBvbmV4aXRyZWZlcmVuY2VzdHJpbmcsXG4gICAgICByZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nOiBvbmV4aXRyZXNvdXJjZWRlc3RpbmF0aW9uc3RyaW5nLFxuICAgICAgcmVzb3VyY2VUaXRsZVN0cmluZzogb25leGl0cmVzb3VyY2V0aXRsZXN0cmluZyxcbiAgICAgIHJlc291cmNlOiBvbmV4aXRyZXNvdXJjZSxcbiAgICAgIHNldGV4dEhlYWRpbmc6IGNsb3NlcihvbmV4aXRzZXRleHRoZWFkaW5nKSxcbiAgICAgIHNldGV4dEhlYWRpbmdMaW5lU2VxdWVuY2U6IG9uZXhpdHNldGV4dGhlYWRpbmdsaW5lc2VxdWVuY2UsXG4gICAgICBzZXRleHRIZWFkaW5nVGV4dDogb25leGl0c2V0ZXh0aGVhZGluZ3RleHQsXG4gICAgICBzdHJvbmc6IGNsb3NlcigpLFxuICAgICAgdGhlbWF0aWNCcmVhazogY2xvc2VyKClcbiAgICB9XG4gIH1cblxuICBjb25maWd1cmUoY29uZmlnLCAob3B0aW9ucyB8fCB7fSkubWRhc3RFeHRlbnNpb25zIHx8IFtdKVxuXG4gIC8qKiBAdHlwZSB7Q29tcGlsZURhdGF9ICovXG4gIGNvbnN0IGRhdGEgPSB7fVxuXG4gIHJldHVybiBjb21waWxlXG5cbiAgLyoqXG4gICAqIFR1cm4gbWljcm9tYXJrIGV2ZW50cyBpbnRvIGFuIG1kYXN0IHRyZWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbiAgICogICBFdmVudHMuXG4gICAqIEByZXR1cm5zIHtSb290fVxuICAgKiAgIG1kYXN0IHRyZWUuXG4gICAqL1xuICBmdW5jdGlvbiBjb21waWxlKGV2ZW50cykge1xuICAgIC8qKiBAdHlwZSB7Um9vdH0gKi9cbiAgICBsZXQgdHJlZSA9IHt0eXBlOiAncm9vdCcsIGNoaWxkcmVuOiBbXX1cbiAgICAvKiogQHR5cGUge09taXQ8Q29tcGlsZUNvbnRleHQsICdzbGljZVNlcmlhbGl6ZSc+fSAqL1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBzdGFjazogW3RyZWVdLFxuICAgICAgdG9rZW5TdGFjazogW10sXG4gICAgICBjb25maWcsXG4gICAgICBlbnRlcixcbiAgICAgIGV4aXQsXG4gICAgICBidWZmZXIsXG4gICAgICByZXN1bWUsXG4gICAgICBkYXRhXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICBjb25zdCBsaXN0U3RhY2sgPSBbXVxuICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIFdlIHByZXByb2Nlc3MgbGlzdHMgdG8gYWRkIGBsaXN0SXRlbWAgdG9rZW5zLCBhbmQgdG8gaW5mZXIgd2hldGhlclxuICAgICAgLy8gaXRlbXMgdGhlIGxpc3QgaXRzZWxmIGFyZSBzcHJlYWQgb3V0LlxuICAgICAgaWYgKFxuICAgICAgICBldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09IHR5cGVzLmxpc3RPcmRlcmVkIHx8XG4gICAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gdHlwZXMubGlzdFVub3JkZXJlZFxuICAgICAgKSB7XG4gICAgICAgIGlmIChldmVudHNbaW5kZXhdWzBdID09PSAnZW50ZXInKSB7XG4gICAgICAgICAgbGlzdFN0YWNrLnB1c2goaW5kZXgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGFpbCA9IGxpc3RTdGFjay5wb3AoKVxuICAgICAgICAgIGFzc2VydCh0eXBlb2YgdGFpbCA9PT0gJ251bWJlcicsICdleHBlY3RlZCBsaXN0IG90IGJlIG9wZW4nKVxuICAgICAgICAgIGluZGV4ID0gcHJlcGFyZUxpc3QoZXZlbnRzLCB0YWlsLCBpbmRleClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4ID0gLTFcblxuICAgIHdoaWxlICgrK2luZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGNvbmZpZ1tldmVudHNbaW5kZXhdWzBdXVxuXG4gICAgICBpZiAob3duLmNhbGwoaGFuZGxlciwgZXZlbnRzW2luZGV4XVsxXS50eXBlKSkge1xuICAgICAgICBoYW5kbGVyW2V2ZW50c1tpbmRleF1bMV0udHlwZV0uY2FsbChcbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge3NsaWNlU2VyaWFsaXplOiBldmVudHNbaW5kZXhdWzJdLnNsaWNlU2VyaWFsaXplfSxcbiAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICApLFxuICAgICAgICAgIGV2ZW50c1tpbmRleF1bMV1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0b2tlbnMgc3RpbGwgYmVpbmcgb3Blbi5cbiAgICBpZiAoY29udGV4dC50b2tlblN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRhaWwgPSBjb250ZXh0LnRva2VuU3RhY2tbY29udGV4dC50b2tlblN0YWNrLmxlbmd0aCAtIDFdXG4gICAgICBjb25zdCBoYW5kbGVyID0gdGFpbFsxXSB8fCBkZWZhdWx0T25FcnJvclxuICAgICAgaGFuZGxlci5jYWxsKGNvbnRleHQsIHVuZGVmaW5lZCwgdGFpbFswXSlcbiAgICB9XG5cbiAgICAvLyBGaWd1cmUgb3V0IGByb290YCBwb3NpdGlvbi5cbiAgICB0cmVlLnBvc2l0aW9uID0ge1xuICAgICAgc3RhcnQ6IHBvaW50KFxuICAgICAgICBldmVudHMubGVuZ3RoID4gMCA/IGV2ZW50c1swXVsxXS5zdGFydCA6IHtsaW5lOiAxLCBjb2x1bW46IDEsIG9mZnNldDogMH1cbiAgICAgICksXG4gICAgICBlbmQ6IHBvaW50KFxuICAgICAgICBldmVudHMubGVuZ3RoID4gMFxuICAgICAgICAgID8gZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAyXVsxXS5lbmRcbiAgICAgICAgICA6IHtsaW5lOiAxLCBjb2x1bW46IDEsIG9mZnNldDogMH1cbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBDYWxsIHRyYW5zZm9ybXMuXG4gICAgaW5kZXggPSAtMVxuICAgIHdoaWxlICgrK2luZGV4IDwgY29uZmlnLnRyYW5zZm9ybXMubGVuZ3RoKSB7XG4gICAgICB0cmVlID0gY29uZmlnLnRyYW5zZm9ybXNbaW5kZXhdKHRyZWUpIHx8IHRyZWVcbiAgICB9XG5cbiAgICByZXR1cm4gdHJlZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIHByZXBhcmVMaXN0KGV2ZW50cywgc3RhcnQsIGxlbmd0aCkge1xuICAgIGxldCBpbmRleCA9IHN0YXJ0IC0gMVxuICAgIGxldCBjb250YWluZXJCYWxhbmNlID0gLTFcbiAgICBsZXQgbGlzdFNwcmVhZCA9IGZhbHNlXG4gICAgLyoqIEB0eXBlIHtUb2tlbiB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgbGlzdEl0ZW1cbiAgICAvKiogQHR5cGUge251bWJlciB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgbGluZUluZGV4XG4gICAgLyoqIEB0eXBlIHtudW1iZXIgfCB1bmRlZmluZWR9ICovXG4gICAgbGV0IGZpcnN0QmxhbmtMaW5lSW5kZXhcbiAgICAvKiogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9ICovXG4gICAgbGV0IGF0TWFya2VyXG5cbiAgICB3aGlsZSAoKytpbmRleCA8PSBsZW5ndGgpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW2luZGV4XVxuXG4gICAgICBzd2l0Y2ggKGV2ZW50WzFdLnR5cGUpIHtcbiAgICAgICAgY2FzZSB0eXBlcy5saXN0VW5vcmRlcmVkOlxuICAgICAgICBjYXNlIHR5cGVzLmxpc3RPcmRlcmVkOlxuICAgICAgICBjYXNlIHR5cGVzLmJsb2NrUXVvdGU6IHtcbiAgICAgICAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckJhbGFuY2UrK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXJCYWxhbmNlLS1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdE1hcmtlciA9IHVuZGVmaW5lZFxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgdHlwZXMubGluZUVuZGluZ0JsYW5rOiB7XG4gICAgICAgICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGxpc3RJdGVtICYmXG4gICAgICAgICAgICAgICFhdE1hcmtlciAmJlxuICAgICAgICAgICAgICAhY29udGFpbmVyQmFsYW5jZSAmJlxuICAgICAgICAgICAgICAhZmlyc3RCbGFua0xpbmVJbmRleFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGZpcnN0QmxhbmtMaW5lSW5kZXggPSBpbmRleFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdE1hcmtlciA9IHVuZGVmaW5lZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIHR5cGVzLmxpbmVQcmVmaXg6XG4gICAgICAgIGNhc2UgdHlwZXMubGlzdEl0ZW1WYWx1ZTpcbiAgICAgICAgY2FzZSB0eXBlcy5saXN0SXRlbU1hcmtlcjpcbiAgICAgICAgY2FzZSB0eXBlcy5saXN0SXRlbVByZWZpeDpcbiAgICAgICAgY2FzZSB0eXBlcy5saXN0SXRlbVByZWZpeFdoaXRlc3BhY2U6IHtcbiAgICAgICAgICAvLyBFbXB0eS5cblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgYXRNYXJrZXIgPSB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgICghY29udGFpbmVyQmFsYW5jZSAmJlxuICAgICAgICAgIGV2ZW50WzBdID09PSAnZW50ZXInICYmXG4gICAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdEl0ZW1QcmVmaXgpIHx8XG4gICAgICAgIChjb250YWluZXJCYWxhbmNlID09PSAtMSAmJlxuICAgICAgICAgIGV2ZW50WzBdID09PSAnZXhpdCcgJiZcbiAgICAgICAgICAoZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdFVub3JkZXJlZCB8fFxuICAgICAgICAgICAgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdE9yZGVyZWQpKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChsaXN0SXRlbSkge1xuICAgICAgICAgIGxldCB0YWlsSW5kZXggPSBpbmRleFxuICAgICAgICAgIGxpbmVJbmRleCA9IHVuZGVmaW5lZFxuXG4gICAgICAgICAgd2hpbGUgKHRhaWxJbmRleC0tKSB7XG4gICAgICAgICAgICBjb25zdCB0YWlsRXZlbnQgPSBldmVudHNbdGFpbEluZGV4XVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lRW5kaW5nIHx8XG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lRW5kaW5nQmxhbmtcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAodGFpbEV2ZW50WzBdID09PSAnZXhpdCcpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgICAgaWYgKGxpbmVJbmRleCkge1xuICAgICAgICAgICAgICAgIGV2ZW50c1tsaW5lSW5kZXhdWzFdLnR5cGUgPSB0eXBlcy5saW5lRW5kaW5nQmxhbmtcbiAgICAgICAgICAgICAgICBsaXN0U3ByZWFkID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPSB0eXBlcy5saW5lRW5kaW5nXG4gICAgICAgICAgICAgIGxpbmVJbmRleCA9IHRhaWxJbmRleFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpbmVQcmVmaXggfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmJsb2NrUXVvdGVQcmVmaXggfHxcbiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmJsb2NrUXVvdGVQcmVmaXhXaGl0ZXNwYWNlIHx8XG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5ibG9ja1F1b3RlTWFya2VyIHx8XG4gICAgICAgICAgICAgIHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0SXRlbUluZGVudFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIEVtcHR5XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZpcnN0QmxhbmtMaW5lSW5kZXggJiZcbiAgICAgICAgICAgICghbGluZUluZGV4IHx8IGZpcnN0QmxhbmtMaW5lSW5kZXggPCBsaW5lSW5kZXgpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBsaXN0SXRlbS5fc3ByZWFkID0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZpeCBwb3NpdGlvbi5cbiAgICAgICAgICBsaXN0SXRlbS5lbmQgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBsaW5lSW5kZXggPyBldmVudHNbbGluZUluZGV4XVsxXS5zdGFydCA6IGV2ZW50WzFdLmVuZFxuICAgICAgICAgIClcblxuICAgICAgICAgIGV2ZW50cy5zcGxpY2UobGluZUluZGV4IHx8IGluZGV4LCAwLCBbJ2V4aXQnLCBsaXN0SXRlbSwgZXZlbnRbMl1dKVxuICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICBsZW5ndGgrK1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxpc3QgaXRlbS5cbiAgICAgICAgaWYgKGV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpc3RJdGVtUHJlZml4KSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgICAgICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICAgICAgdHlwZTogJ2xpc3RJdGVtJyxcbiAgICAgICAgICAgIF9zcHJlYWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50WzFdLnN0YXJ0KSxcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdl4oCZbGwgYWRkIGBlbmRgIGluIGEgc2Vjb25kLlxuICAgICAgICAgICAgZW5kOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgbGlzdEl0ZW0gPSBpdGVtXG4gICAgICAgICAgZXZlbnRzLnNwbGljZShpbmRleCwgMCwgWydlbnRlcicsIGl0ZW0sIGV2ZW50WzJdXSlcbiAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgbGVuZ3RoKytcbiAgICAgICAgICBmaXJzdEJsYW5rTGluZUluZGV4ID0gdW5kZWZpbmVkXG4gICAgICAgICAgYXRNYXJrZXIgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBldmVudHNbc3RhcnRdWzFdLl9zcHJlYWQgPSBsaXN0U3ByZWFkXG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBvcGVuZXIgaGFuZGxlLlxuICAgKlxuICAgKiBAcGFyYW0geyh0b2tlbjogVG9rZW4pID0+IE5vZGVzfSBjcmVhdGVcbiAgICogICBDcmVhdGUgYSBub2RlLlxuICAgKiBAcGFyYW0ge0hhbmRsZSB8IHVuZGVmaW5lZH0gW2FuZF1cbiAgICogICBPcHRpb25hbCBmdW5jdGlvbiB0byBhbHNvIHJ1bi5cbiAgICogQHJldHVybnMge0hhbmRsZX1cbiAgICogICBIYW5kbGUuXG4gICAqL1xuICBmdW5jdGlvbiBvcGVuZXIoY3JlYXRlLCBhbmQpIHtcbiAgICByZXR1cm4gb3BlblxuXG4gICAgLyoqXG4gICAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcGVuKHRva2VuKSB7XG4gICAgICBlbnRlci5jYWxsKHRoaXMsIGNyZWF0ZSh0b2tlbiksIHRva2VuKVxuICAgICAgaWYgKGFuZCkgYW5kLmNhbGwodGhpcywgdG9rZW4pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIGJ1ZmZlcigpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goe3R5cGU6ICdmcmFnbWVudCcsIGNoaWxkcmVuOiBbXX0pXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiAgIENvbnRleHQuXG4gICAqIEBwYXJhbSB7Tm9kZXN9IG5vZGVcbiAgICogICBOb2RlIHRvIGVudGVyLlxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiAgIENvcnJlc3BvbmRpbmcgdG9rZW4uXG4gICAqIEBwYXJhbSB7T25FbnRlckVycm9yIHwgdW5kZWZpbmVkfSBbZXJyb3JIYW5kbGVyXVxuICAgKiAgIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGlzIHRva2VuIGlzIG9wZW4sIGJ1dCBpdCBpcyBjbG9zZWQgYnkgc29tZXRoaW5nIGVsc2UuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqICAgTm90aGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGVudGVyKG5vZGUsIHRva2VuLCBlcnJvckhhbmRsZXIpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQocGFyZW50LCAnZXhwZWN0ZWQgYHBhcmVudGAnKVxuICAgIGFzc2VydCgnY2hpbGRyZW4nIGluIHBhcmVudCwgJ2V4cGVjdGVkIGBwYXJlbnRgJylcbiAgICAvKiogQHR5cGUge0FycmF5PE5vZGVzPn0gKi9cbiAgICBjb25zdCBzaWJsaW5ncyA9IHBhcmVudC5jaGlsZHJlblxuICAgIHNpYmxpbmdzLnB1c2gobm9kZSlcbiAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSlcbiAgICB0aGlzLnRva2VuU3RhY2sucHVzaChbdG9rZW4sIGVycm9ySGFuZGxlcl0pXG4gICAgbm9kZS5wb3NpdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBwb2ludCh0b2tlbi5zdGFydCksXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgZW5kYCB3aWxsIGJlIHBhdGNoZWQgbGF0ZXIuXG4gICAgICBlbmQ6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjbG9zZXIgaGFuZGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge0hhbmRsZSB8IHVuZGVmaW5lZH0gW2FuZF1cbiAgICogICBPcHRpb25hbCBmdW5jdGlvbiB0byBhbHNvIHJ1bi5cbiAgICogQHJldHVybnMge0hhbmRsZX1cbiAgICogICBIYW5kbGUuXG4gICAqL1xuICBmdW5jdGlvbiBjbG9zZXIoYW5kKSB7XG4gICAgcmV0dXJuIGNsb3NlXG5cbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb3NlKHRva2VuKSB7XG4gICAgICBpZiAoYW5kKSBhbmQuY2FsbCh0aGlzLCB0b2tlbilcbiAgICAgIGV4aXQuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiAgIENvbnRleHQuXG4gICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAqICAgQ29ycmVzcG9uZGluZyB0b2tlbi5cbiAgICogQHBhcmFtIHtPbkV4aXRFcnJvciB8IHVuZGVmaW5lZH0gW29uRXhpdEVycm9yXVxuICAgKiAgIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbm90aGVyIHRva2VuIGlzIG9wZW4uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqICAgTm90aGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXQodG9rZW4sIG9uRXhpdEVycm9yKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2sucG9wKClcbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIGBub2RlYCcpXG4gICAgY29uc3Qgb3BlbiA9IHRoaXMudG9rZW5TdGFjay5wb3AoKVxuXG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgY2xvc2UgYCcgK1xuICAgICAgICAgIHRva2VuLnR5cGUgK1xuICAgICAgICAgICdgICgnICtcbiAgICAgICAgICBzdHJpbmdpZnlQb3NpdGlvbih7c3RhcnQ6IHRva2VuLnN0YXJ0LCBlbmQ6IHRva2VuLmVuZH0pICtcbiAgICAgICAgICAnKTogaXTigJlzIG5vdCBvcGVuJ1xuICAgICAgKVxuICAgIH0gZWxzZSBpZiAob3BlblswXS50eXBlICE9PSB0b2tlbi50eXBlKSB7XG4gICAgICBpZiAob25FeGl0RXJyb3IpIHtcbiAgICAgICAgb25FeGl0RXJyb3IuY2FsbCh0aGlzLCB0b2tlbiwgb3BlblswXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBvcGVuWzFdIHx8IGRlZmF1bHRPbkVycm9yXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCB0b2tlbiwgb3BlblswXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3NlcnQobm9kZS50eXBlICE9PSAnZnJhZ21lbnQnLCAndW5leHBlY3RlZCBmcmFnbWVudCBgZXhpdGBlZCcpXG4gICAgYXNzZXJ0KG5vZGUucG9zaXRpb24sICdleHBlY3RlZCBgcG9zaXRpb25gIHRvIGJlIGRlZmluZWQnKVxuICAgIG5vZGUucG9zaXRpb24uZW5kID0gcG9pbnQodG9rZW4uZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcodGhpcy5zdGFjay5wb3AoKSlcbiAgfVxuXG4gIC8vXG4gIC8vIEhhbmRsZXJzLlxuICAvL1xuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmVudGVybGlzdG9yZGVyZWQoKSB7XG4gICAgdGhpcy5kYXRhLmV4cGVjdGluZ0ZpcnN0TGlzdEl0ZW1WYWx1ZSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmVudGVybGlzdGl0ZW12YWx1ZSh0b2tlbikge1xuICAgIGlmICh0aGlzLmRhdGEuZXhwZWN0aW5nRmlyc3RMaXN0SXRlbVZhbHVlKSB7XG4gICAgICBjb25zdCBhbmNlc3RvciA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXVxuICAgICAgYXNzZXJ0KGFuY2VzdG9yLCAnZXhwZWN0ZWQgbm9kZXMgb24gc3RhY2snKVxuICAgICAgYXNzZXJ0KGFuY2VzdG9yLnR5cGUgPT09ICdsaXN0JywgJ2V4cGVjdGVkIGxpc3Qgb24gc3RhY2snKVxuICAgICAgYW5jZXN0b3Iuc3RhcnQgPSBOdW1iZXIucGFyc2VJbnQoXG4gICAgICAgIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLFxuICAgICAgICBjb25zdGFudHMubnVtZXJpY0Jhc2VEZWNpbWFsXG4gICAgICApXG4gICAgICB0aGlzLmRhdGEuZXhwZWN0aW5nRmlyc3RMaXN0SXRlbVZhbHVlID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGNvZGVmZW5jZWRmZW5jZWluZm8oKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnY29kZScsICdleHBlY3RlZCBjb2RlIG9uIHN0YWNrJylcbiAgICBub2RlLmxhbmcgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZGZlbmNlbWV0YSgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdjb2RlJywgJ2V4cGVjdGVkIGNvZGUgb24gc3RhY2snKVxuICAgIG5vZGUubWV0YSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRjb2RlZmVuY2VkZmVuY2UoKSB7XG4gICAgLy8gRXhpdCBpZiB0aGlzIGlzIHRoZSBjbG9zaW5nIGZlbmNlLlxuICAgIGlmICh0aGlzLmRhdGEuZmxvd0NvZGVJbnNpZGUpIHJldHVyblxuICAgIHRoaXMuYnVmZmVyKClcbiAgICB0aGlzLmRhdGEuZmxvd0NvZGVJbnNpZGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZCgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdjb2RlJywgJ2V4cGVjdGVkIGNvZGUgb24gc3RhY2snKVxuXG4gICAgbm9kZS52YWx1ZSA9IGRhdGEucmVwbGFjZSgvXihcXHI/XFxufFxccil8KFxccj9cXG58XFxyKSQvZywgJycpXG4gICAgdGhpcy5kYXRhLmZsb3dDb2RlSW5zaWRlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0Y29kZWluZGVudGVkKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2NvZGUnLCAnZXhwZWN0ZWQgY29kZSBvbiBzdGFjaycpXG5cbiAgICBub2RlLnZhbHVlID0gZGF0YS5yZXBsYWNlKC8oXFxyP1xcbnxcXHIpJC9nLCAnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRkZWZpbml0aW9ubGFiZWxzdHJpbmcodG9rZW4pIHtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnZGVmaW5pdGlvbicsICdleHBlY3RlZCBkZWZpbml0aW9uIG9uIHN0YWNrJylcblxuICAgIG5vZGUubGFiZWwgPSBsYWJlbFxuICAgIG5vZGUuaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoXG4gICAgICB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICAgICkudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGRlZmluaXRpb250aXRsZXN0cmluZygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdkZWZpbml0aW9uJywgJ2V4cGVjdGVkIGRlZmluaXRpb24gb24gc3RhY2snKVxuXG4gICAgbm9kZS50aXRsZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRkZWZpbml0aW9uZGVzdGluYXRpb25zdHJpbmcoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnZGVmaW5pdGlvbicsICdleHBlY3RlZCBkZWZpbml0aW9uIG9uIHN0YWNrJylcblxuICAgIG5vZGUudXJsID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGF0eGhlYWRpbmdzZXF1ZW5jZSh0b2tlbikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdoZWFkaW5nJywgJ2V4cGVjdGVkIGhlYWRpbmcgb24gc3RhY2snKVxuXG4gICAgaWYgKCFub2RlLmRlcHRoKSB7XG4gICAgICBjb25zdCBkZXB0aCA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLmxlbmd0aFxuXG4gICAgICBhc3NlcnQoXG4gICAgICAgIGRlcHRoID09PSAxIHx8XG4gICAgICAgICAgZGVwdGggPT09IDIgfHxcbiAgICAgICAgICBkZXB0aCA9PT0gMyB8fFxuICAgICAgICAgIGRlcHRoID09PSA0IHx8XG4gICAgICAgICAgZGVwdGggPT09IDUgfHxcbiAgICAgICAgICBkZXB0aCA9PT0gNixcbiAgICAgICAgJ2V4cGVjdGVkIGBkZXB0aGAgYmV0d2VlbiBgMWAgYW5kIGA2YCdcbiAgICAgIClcblxuICAgICAgbm9kZS5kZXB0aCA9IGRlcHRoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmd0ZXh0KCkge1xuICAgIHRoaXMuZGF0YS5zZXRleHRIZWFkaW5nU2x1cnBMaW5lRW5kaW5nID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmdsaW5lc2VxdWVuY2UodG9rZW4pIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnaGVhZGluZycsICdleHBlY3RlZCBoZWFkaW5nIG9uIHN0YWNrJylcblxuICAgIG5vZGUuZGVwdGggPVxuICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbikuY29kZVBvaW50QXQoMCkgPT09IGNvZGVzLmVxdWFsc1RvID8gMSA6IDJcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRzZXRleHRoZWFkaW5nKCkge1xuICAgIHRoaXMuZGF0YS5zZXRleHRIZWFkaW5nU2x1cnBMaW5lRW5kaW5nID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmVudGVyZGF0YSh0b2tlbikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydCgnY2hpbGRyZW4nIGluIG5vZGUsICdleHBlY3RlZCBwYXJlbnQgb24gc3RhY2snKVxuICAgIC8qKiBAdHlwZSB7QXJyYXk8Tm9kZXM+fSAqL1xuICAgIGNvbnN0IHNpYmxpbmdzID0gbm9kZS5jaGlsZHJlblxuXG4gICAgbGV0IHRhaWwgPSBzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXVxuXG4gICAgaWYgKCF0YWlsIHx8IHRhaWwudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAvLyBBZGQgYSBuZXcgdGV4dCBub2RlLlxuICAgICAgdGFpbCA9IHRleHQoKVxuICAgICAgdGFpbC5wb3NpdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IHBvaW50KHRva2VuLnN0YXJ0KSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogd2XigJlsbCBhZGQgYGVuZGAgbGF0ZXIuXG4gICAgICAgIGVuZDogdW5kZWZpbmVkXG4gICAgICB9XG4gICAgICBzaWJsaW5ncy5wdXNoKHRhaWwpXG4gICAgfVxuXG4gICAgdGhpcy5zdGFjay5wdXNoKHRhaWwpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRkYXRhKHRva2VuKSB7XG4gICAgY29uc3QgdGFpbCA9IHRoaXMuc3RhY2sucG9wKClcbiAgICBhc3NlcnQodGFpbCwgJ2V4cGVjdGVkIGEgYG5vZGVgIHRvIGJlIG9uIHRoZSBzdGFjaycpXG4gICAgYXNzZXJ0KCd2YWx1ZScgaW4gdGFpbCwgJ2V4cGVjdGVkIGEgYGxpdGVyYWxgIHRvIGJlIG9uIHRoZSBzdGFjaycpXG4gICAgYXNzZXJ0KHRhaWwucG9zaXRpb24sICdleHBlY3RlZCBgbm9kZWAgdG8gaGF2ZSBhbiBvcGVuIHBvc2l0aW9uJylcbiAgICB0YWlsLnZhbHVlICs9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRsaW5lZW5kaW5nKHRva2VuKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChjb250ZXh0LCAnZXhwZWN0ZWQgYG5vZGVgJylcblxuICAgIC8vIElmIHdl4oCZcmUgYXQgYSBoYXJkIGJyZWFrLCBpbmNsdWRlIHRoZSBsaW5lIGVuZGluZyBpbiB0aGVyZS5cbiAgICBpZiAodGhpcy5kYXRhLmF0SGFyZEJyZWFrKSB7XG4gICAgICBhc3NlcnQoJ2NoaWxkcmVuJyBpbiBjb250ZXh0LCAnZXhwZWN0ZWQgYHBhcmVudGAnKVxuICAgICAgY29uc3QgdGFpbCA9IGNvbnRleHQuY2hpbGRyZW5bY29udGV4dC5jaGlsZHJlbi5sZW5ndGggLSAxXVxuICAgICAgYXNzZXJ0KHRhaWwucG9zaXRpb24sICdleHBlY3RlZCB0YWlsIHRvIGhhdmUgYSBzdGFydGluZyBwb3NpdGlvbicpXG4gICAgICB0YWlsLnBvc2l0aW9uLmVuZCA9IHBvaW50KHRva2VuLmVuZClcbiAgICAgIHRoaXMuZGF0YS5hdEhhcmRCcmVhayA9IHVuZGVmaW5lZFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIXRoaXMuZGF0YS5zZXRleHRIZWFkaW5nU2x1cnBMaW5lRW5kaW5nICYmXG4gICAgICBjb25maWcuY2FuQ29udGFpbkVvbHMuaW5jbHVkZXMoY29udGV4dC50eXBlKVxuICAgICkge1xuICAgICAgb25lbnRlcmRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICAgIG9uZXhpdGRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRoYXJkYnJlYWsoKSB7XG4gICAgdGhpcy5kYXRhLmF0SGFyZEJyZWFrID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0aHRtbGZsb3coKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnaHRtbCcsICdleHBlY3RlZCBodG1sIG9uIHN0YWNrJylcblxuICAgIG5vZGUudmFsdWUgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRodG1sdGV4dCgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdodG1sJywgJ2V4cGVjdGVkIGh0bWwgb24gc3RhY2snKVxuXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGNvZGV0ZXh0KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2lubGluZUNvZGUnLCAnZXhwZWN0ZWQgaW5saW5lIGNvZGUgb24gc3RhY2snKVxuXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGxpbmsoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLCAnZXhwZWN0ZWQgbm9kZSBvbiBzdGFjaycpXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2xpbmsnLCAnZXhwZWN0ZWQgbGluayBvbiBzdGFjaycpXG5cbiAgICAvLyBOb3RlOiB0aGVyZSBhcmUgYWxzbyBgaWRlbnRpZmllcmAgYW5kIGBsYWJlbGAgZmllbGRzIG9uIHRoaXMgbGluayBub2RlIVxuICAgIC8vIFRoZXNlIGFyZSB1c2VkIC8gY2xlYW5lZCBoZXJlLlxuXG4gICAgLy8gVG8gZG86IGNsZWFuLlxuICAgIGlmICh0aGlzLmRhdGEuaW5SZWZlcmVuY2UpIHtcbiAgICAgIC8qKiBAdHlwZSB7UmVmZXJlbmNlVHlwZX0gKi9cbiAgICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSB0aGlzLmRhdGEucmVmZXJlbmNlVHlwZSB8fCAnc2hvcnRjdXQnXG5cbiAgICAgIG5vZGUudHlwZSArPSAnUmVmZXJlbmNlJ1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgbm9kZS5yZWZlcmVuY2VUeXBlID0gcmVmZXJlbmNlVHlwZVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgZGVsZXRlIG5vZGUudXJsXG4gICAgICBkZWxldGUgbm9kZS50aXRsZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS5pZGVudGlmaWVyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBtdXRhdGUuXG4gICAgICBkZWxldGUgbm9kZS5sYWJlbFxuICAgIH1cblxuICAgIHRoaXMuZGF0YS5yZWZlcmVuY2VUeXBlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRpbWFnZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnaW1hZ2UnLCAnZXhwZWN0ZWQgaW1hZ2Ugb24gc3RhY2snKVxuXG4gICAgLy8gTm90ZTogdGhlcmUgYXJlIGFsc28gYGlkZW50aWZpZXJgIGFuZCBgbGFiZWxgIGZpZWxkcyBvbiB0aGlzIGxpbmsgbm9kZSFcbiAgICAvLyBUaGVzZSBhcmUgdXNlZCAvIGNsZWFuZWQgaGVyZS5cblxuICAgIC8vIFRvIGRvOiBjbGVhbi5cbiAgICBpZiAodGhpcy5kYXRhLmluUmVmZXJlbmNlKSB7XG4gICAgICAvKiogQHR5cGUge1JlZmVyZW5jZVR5cGV9ICovXG4gICAgICBjb25zdCByZWZlcmVuY2VUeXBlID0gdGhpcy5kYXRhLnJlZmVyZW5jZVR5cGUgfHwgJ3Nob3J0Y3V0J1xuXG4gICAgICBub2RlLnR5cGUgKz0gJ1JlZmVyZW5jZSdcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cbiAgICAgIG5vZGUucmVmZXJlbmNlVHlwZSA9IHJlZmVyZW5jZVR5cGVcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG11dGF0ZS5cbiAgICAgIGRlbGV0ZSBub2RlLnVybFxuICAgICAgZGVsZXRlIG5vZGUudGl0bGVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgZGVsZXRlIG5vZGUuaWRlbnRpZmllclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbXV0YXRlLlxuICAgICAgZGVsZXRlIG5vZGUubGFiZWxcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEucmVmZXJlbmNlVHlwZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0bGFiZWx0ZXh0KHRva2VuKSB7XG4gICAgY29uc3Qgc3RyaW5nID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgICBjb25zdCBhbmNlc3RvciA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXVxuICAgIGFzc2VydChhbmNlc3RvciwgJ2V4cGVjdGVkIGFuY2VzdG9yIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoXG4gICAgICBhbmNlc3Rvci50eXBlID09PSAnaW1hZ2UnIHx8IGFuY2VzdG9yLnR5cGUgPT09ICdsaW5rJyxcbiAgICAgICdleHBlY3RlZCBpbWFnZSBvciBsaW5rIG9uIHN0YWNrJ1xuICAgIClcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHN0YXNoIHRoaXMgb24gdGhlIG5vZGUsIGFzIGl0IG1pZ2h0IGJlY29tZSBhIHJlZmVyZW5jZVxuICAgIC8vIGxhdGVyLlxuICAgIGFuY2VzdG9yLmxhYmVsID0gZGVjb2RlU3RyaW5nKHN0cmluZylcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzYW1lIGFzIGFib3ZlLlxuICAgIGFuY2VzdG9yLmlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKHN0cmluZykudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0bGFiZWwoKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQoZnJhZ21lbnQsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoZnJhZ21lbnQudHlwZSA9PT0gJ2ZyYWdtZW50JywgJ2V4cGVjdGVkIGZyYWdtZW50IG9uIHN0YWNrJylcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoXG4gICAgICBub2RlLnR5cGUgPT09ICdpbWFnZScgfHwgbm9kZS50eXBlID09PSAnbGluaycsXG4gICAgICAnZXhwZWN0ZWQgaW1hZ2Ugb3IgbGluayBvbiBzdGFjaydcbiAgICApXG5cbiAgICAvLyBBc3N1bWUgYSByZWZlcmVuY2UuXG4gICAgdGhpcy5kYXRhLmluUmVmZXJlbmNlID0gdHJ1ZVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PFBocmFzaW5nQ29udGVudD59ICovXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGZyYWdtZW50LmNoaWxkcmVuXG5cbiAgICAgIG5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmFsdCA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25leGl0cmVzb3VyY2VkZXN0aW5hdGlvbnN0cmluZygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2ltYWdlJyB8fCBub2RlLnR5cGUgPT09ICdsaW5rJyxcbiAgICAgICdleHBlY3RlZCBpbWFnZSBvciBsaW5rIG9uIHN0YWNrJ1xuICAgIClcbiAgICBub2RlLnVybCA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHJlc291cmNldGl0bGVzdHJpbmcoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoXG4gICAgICBub2RlLnR5cGUgPT09ICdpbWFnZScgfHwgbm9kZS50eXBlID09PSAnbGluaycsXG4gICAgICAnZXhwZWN0ZWQgaW1hZ2Ugb3IgbGluayBvbiBzdGFjaydcbiAgICApXG4gICAgbm9kZS50aXRsZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdHJlc291cmNlKCkge1xuICAgIHRoaXMuZGF0YS5pblJlZmVyZW5jZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gb25lbnRlcnJlZmVyZW5jZSgpIHtcbiAgICB0aGlzLmRhdGEucmVmZXJlbmNlVHlwZSA9ICdjb2xsYXBzZWQnXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cblxuICBmdW5jdGlvbiBvbmV4aXRyZWZlcmVuY2VzdHJpbmcodG9rZW4pIHtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQoXG4gICAgICBub2RlLnR5cGUgPT09ICdpbWFnZScgfHwgbm9kZS50eXBlID09PSAnbGluaycsXG4gICAgICAnZXhwZWN0ZWQgaW1hZ2UgcmVmZXJlbmNlIG9yIGxpbmsgcmVmZXJlbmNlIG9uIHN0YWNrJ1xuICAgIClcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHN0YXNoIHRoaXMgb24gdGhlIG5vZGUsIGFzIGl0IG1pZ2h0IGJlY29tZSBhIHJlZmVyZW5jZVxuICAgIC8vIGxhdGVyLlxuICAgIG5vZGUubGFiZWwgPSBsYWJlbFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHNhbWUgYXMgYWJvdmUuXG4gICAgbm9kZS5pZGVudGlmaWVyID0gbm9ybWFsaXplSWRlbnRpZmllcihcbiAgICAgIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gICAgKS50b0xvd2VyQ2FzZSgpXG4gICAgdGhpcy5kYXRhLnJlZmVyZW5jZVR5cGUgPSAnZnVsbCdcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZW1hcmtlcih0b2tlbikge1xuICAgIGFzc2VydChcbiAgICAgIHRva2VuLnR5cGUgPT09ICdjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljJyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAnY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VySGV4YWRlY2ltYWwnXG4gICAgKVxuICAgIHRoaXMuZGF0YS5jaGFyYWN0ZXJSZWZlcmVuY2VUeXBlID0gdG9rZW4udHlwZVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0hhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZXZhbHVlKHRva2VuKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZGF0YS5jaGFyYWN0ZXJSZWZlcmVuY2VUeXBlXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgbGV0IHZhbHVlXG5cbiAgICBpZiAodHlwZSkge1xuICAgICAgdmFsdWUgPSBkZWNvZGVOdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlKFxuICAgICAgICBkYXRhLFxuICAgICAgICB0eXBlID09PSB0eXBlcy5jaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljXG4gICAgICAgICAgPyBjb25zdGFudHMubnVtZXJpY0Jhc2VEZWNpbWFsXG4gICAgICAgICAgOiBjb25zdGFudHMubnVtZXJpY0Jhc2VIZXhhZGVjaW1hbFxuICAgICAgKVxuICAgICAgdGhpcy5kYXRhLmNoYXJhY3RlclJlZmVyZW5jZVR5cGUgPSB1bmRlZmluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZGVjb2RlTmFtZWRDaGFyYWN0ZXJSZWZlcmVuY2UoZGF0YSlcbiAgICAgIGFzc2VydChyZXN1bHQgIT09IGZhbHNlLCAnZXhwZWN0ZWQgcmVmZXJlbmNlIHRvIGRlY29kZScpXG4gICAgICB2YWx1ZSA9IHJlc3VsdFxuICAgIH1cblxuICAgIGNvbnN0IHRhaWwgPSB0aGlzLnN0YWNrLnBvcCgpXG4gICAgYXNzZXJ0KHRhaWwsICdleHBlY3RlZCBgbm9kZWAnKVxuICAgIGFzc2VydCh0YWlsLnBvc2l0aW9uLCAnZXhwZWN0ZWQgYG5vZGUucG9zaXRpb25gJylcbiAgICBhc3NlcnQoJ3ZhbHVlJyBpbiB0YWlsLCAnZXhwZWN0ZWQgYG5vZGUudmFsdWVgJylcbiAgICB0YWlsLnZhbHVlICs9IHZhbHVlXG4gICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludCh0b2tlbi5lbmQpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7SGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gb25leGl0YXV0b2xpbmtwcm90b2NvbCh0b2tlbikge1xuICAgIG9uZXhpdGRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUsICdleHBlY3RlZCBub2RlIG9uIHN0YWNrJylcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSAnbGluaycsICdleHBlY3RlZCBsaW5rIG9uIHN0YWNrJylcblxuICAgIG5vZGUudXJsID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtIYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBvbmV4aXRhdXRvbGlua2VtYWlsKHRva2VuKSB7XG4gICAgb25leGl0ZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgICBhc3NlcnQobm9kZSwgJ2V4cGVjdGVkIG5vZGUgb24gc3RhY2snKVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdsaW5rJywgJ2V4cGVjdGVkIGxpbmsgb24gc3RhY2snKVxuXG4gICAgbm9kZS51cmwgPSAnbWFpbHRvOicgKyB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB9XG5cbiAgLy9cbiAgLy8gQ3JlYXRlcnMuXG4gIC8vXG5cbiAgLyoqIEByZXR1cm5zIHtCbG9ja3F1b3RlfSAqL1xuICBmdW5jdGlvbiBibG9ja1F1b3RlKCkge1xuICAgIHJldHVybiB7dHlwZTogJ2Jsb2NrcXVvdGUnLCBjaGlsZHJlbjogW119XG4gIH1cblxuICAvKiogQHJldHVybnMge0NvZGV9ICovXG4gIGZ1bmN0aW9uIGNvZGVGbG93KCkge1xuICAgIHJldHVybiB7dHlwZTogJ2NvZGUnLCBsYW5nOiBudWxsLCBtZXRhOiBudWxsLCB2YWx1ZTogJyd9XG4gIH1cblxuICAvKiogQHJldHVybnMge0lubGluZUNvZGV9ICovXG4gIGZ1bmN0aW9uIGNvZGVUZXh0KCkge1xuICAgIHJldHVybiB7dHlwZTogJ2lubGluZUNvZGUnLCB2YWx1ZTogJyd9XG4gIH1cblxuICAvKiogQHJldHVybnMge0RlZmluaXRpb259ICovXG4gIGZ1bmN0aW9uIGRlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdkZWZpbml0aW9uJyxcbiAgICAgIGlkZW50aWZpZXI6ICcnLFxuICAgICAgbGFiZWw6IG51bGwsXG4gICAgICB0aXRsZTogbnVsbCxcbiAgICAgIHVybDogJydcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybnMge0VtcGhhc2lzfSAqL1xuICBmdW5jdGlvbiBlbXBoYXNpcygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdlbXBoYXNpcycsIGNoaWxkcmVuOiBbXX1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7SGVhZGluZ30gKi9cbiAgZnVuY3Rpb24gaGVhZGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgZGVwdGhgIHdpbGwgYmUgc2V0IGxhdGVyLlxuICAgICAgZGVwdGg6IDAsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybnMge0JyZWFrfSAqL1xuICBmdW5jdGlvbiBoYXJkQnJlYWsoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnYnJlYWsnfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtIdG1sfSAqL1xuICBmdW5jdGlvbiBodG1sKCkge1xuICAgIHJldHVybiB7dHlwZTogJ2h0bWwnLCB2YWx1ZTogJyd9XG4gIH1cblxuICAvKiogQHJldHVybnMge0ltYWdlfSAqL1xuICBmdW5jdGlvbiBpbWFnZSgpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdpbWFnZScsIHRpdGxlOiBudWxsLCB1cmw6ICcnLCBhbHQ6IG51bGx9XG4gIH1cblxuICAvKiogQHJldHVybnMge0xpbmt9ICovXG4gIGZ1bmN0aW9uIGxpbmsoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnbGluaycsIHRpdGxlOiBudWxsLCB1cmw6ICcnLCBjaGlsZHJlbjogW119XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICogQHJldHVybnMge0xpc3R9XG4gICAqL1xuICBmdW5jdGlvbiBsaXN0KHRva2VuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgIG9yZGVyZWQ6IHRva2VuLnR5cGUgPT09ICdsaXN0T3JkZXJlZCcsXG4gICAgICBzdGFydDogbnVsbCxcbiAgICAgIHNwcmVhZDogdG9rZW4uX3NwcmVhZCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiBAcmV0dXJucyB7TGlzdEl0ZW19XG4gICAqL1xuICBmdW5jdGlvbiBsaXN0SXRlbSh0b2tlbikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnbGlzdEl0ZW0nLFxuICAgICAgc3ByZWFkOiB0b2tlbi5fc3ByZWFkLFxuICAgICAgY2hlY2tlZDogbnVsbCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7UGFyYWdyYXBofSAqL1xuICBmdW5jdGlvbiBwYXJhZ3JhcGgoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAncGFyYWdyYXBoJywgY2hpbGRyZW46IFtdfVxuICB9XG5cbiAgLyoqIEByZXR1cm5zIHtTdHJvbmd9ICovXG4gIGZ1bmN0aW9uIHN0cm9uZygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdzdHJvbmcnLCBjaGlsZHJlbjogW119XG4gIH1cblxuICAvKiogQHJldHVybnMge1RleHR9ICovXG4gIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAndGV4dCcsIHZhbHVlOiAnJ31cbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7VGhlbWF0aWNCcmVha30gKi9cbiAgZnVuY3Rpb24gdGhlbWF0aWNCcmVhaygpIHtcbiAgICByZXR1cm4ge3R5cGU6ICd0aGVtYXRpY0JyZWFrJ31cbiAgfVxufVxuXG4vKipcbiAqIENvcHkgYSBwb2ludC1saWtlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7UG9pbnR9IGRcbiAqICAgUG9pbnQtbGlrZSB2YWx1ZS5cbiAqIEByZXR1cm5zIHtQb2ludH1cbiAqICAgdW5pc3QgcG9pbnQuXG4gKi9cbmZ1bmN0aW9uIHBvaW50KGQpIHtcbiAgcmV0dXJuIHtsaW5lOiBkLmxpbmUsIGNvbHVtbjogZC5jb2x1bW4sIG9mZnNldDogZC5vZmZzZXR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb25maWd9IGNvbWJpbmVkXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEV4dGVuc2lvbj4gfCBFeHRlbnNpb24+fSBleHRlbnNpb25zXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoY29tYmluZWQsIGV4dGVuc2lvbnMpIHtcbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGV4dGVuc2lvbnMubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb25zW2luZGV4XVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjb25maWd1cmUoY29tYmluZWQsIHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbnNpb24oY29tYmluZWQsIHZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29uZmlnfSBjb21iaW5lZFxuICogQHBhcmFtIHtFeHRlbnNpb259IGV4dGVuc2lvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZXh0ZW5zaW9uKGNvbWJpbmVkLCBleHRlbnNpb24pIHtcbiAgLyoqIEB0eXBlIHtrZXlvZiBFeHRlbnNpb259ICovXG4gIGxldCBrZXlcblxuICBmb3IgKGtleSBpbiBleHRlbnNpb24pIHtcbiAgICBpZiAob3duLmNhbGwoZXh0ZW5zaW9uLCBrZXkpKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlICdjYW5Db250YWluRW9scyc6IHtcbiAgICAgICAgICBjb25zdCByaWdodCA9IGV4dGVuc2lvbltrZXldXG4gICAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICBjb21iaW5lZFtrZXldLnB1c2goLi4ucmlnaHQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3RyYW5zZm9ybXMnOiB7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSBleHRlbnNpb25ba2V5XVxuICAgICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgY29tYmluZWRba2V5XS5wdXNoKC4uLnJpZ2h0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlICdlbnRlcic6XG4gICAgICAgIGNhc2UgJ2V4aXQnOiB7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSBleHRlbnNpb25ba2V5XVxuICAgICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjb21iaW5lZFtrZXldLCByaWdodClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIGRlZmF1bHRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqIEB0eXBlIHtPbkVudGVyRXJyb3J9ICovXG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihsZWZ0LCByaWdodCkge1xuICBpZiAobGVmdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3QgY2xvc2UgYCcgK1xuICAgICAgICBsZWZ0LnR5cGUgK1xuICAgICAgICAnYCAoJyArXG4gICAgICAgIHN0cmluZ2lmeVBvc2l0aW9uKHtzdGFydDogbGVmdC5zdGFydCwgZW5kOiBsZWZ0LmVuZH0pICtcbiAgICAgICAgJyk6IGEgZGlmZmVyZW50IHRva2VuIChgJyArXG4gICAgICAgIHJpZ2h0LnR5cGUgK1xuICAgICAgICAnYCwgJyArXG4gICAgICAgIHN0cmluZ2lmeVBvc2l0aW9uKHtzdGFydDogcmlnaHQuc3RhcnQsIGVuZDogcmlnaHQuZW5kfSkgK1xuICAgICAgICAnKSBpcyBvcGVuJ1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2Fubm90IGNsb3NlIGRvY3VtZW50LCBhIHRva2VuIChgJyArXG4gICAgICAgIHJpZ2h0LnR5cGUgK1xuICAgICAgICAnYCwgJyArXG4gICAgICAgIHN0cmluZ2lmeVBvc2l0aW9uKHtzdGFydDogcmlnaHQuc3RhcnQsIGVuZDogcmlnaHQuZW5kfSkgK1xuICAgICAgICAnKSBpcyBzdGlsbCBvcGVuJ1xuICAgIClcbiAgfVxufVxuIl0sIm5hbWVzIjpbIm9rIiwiYXNzZXJ0IiwidG9TdHJpbmciLCJwYXJzZSIsInBvc3Rwcm9jZXNzIiwicHJlcHJvY2VzcyIsImRlY29kZU51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2UiLCJkZWNvZGVTdHJpbmciLCJub3JtYWxpemVJZGVudGlmaWVyIiwiY29kZXMiLCJjb25zdGFudHMiLCJ0eXBlcyIsImRlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlIiwic3RyaW5naWZ5UG9zaXRpb24iLCJvd24iLCJoYXNPd25Qcm9wZXJ0eSIsImZyb21NYXJrZG93biIsInZhbHVlIiwiZW5jb2RpbmciLCJvcHRpb25zIiwidW5kZWZpbmVkIiwiY29tcGlsZXIiLCJkb2N1bWVudCIsIndyaXRlIiwiY29uZmlnIiwidHJhbnNmb3JtcyIsImNhbkNvbnRhaW5Fb2xzIiwiZW50ZXIiLCJhdXRvbGluayIsIm9wZW5lciIsImxpbmsiLCJhdXRvbGlua1Byb3RvY29sIiwib25lbnRlcmRhdGEiLCJhdXRvbGlua0VtYWlsIiwiYXR4SGVhZGluZyIsImhlYWRpbmciLCJibG9ja1F1b3RlIiwiY2hhcmFjdGVyRXNjYXBlIiwiY2hhcmFjdGVyUmVmZXJlbmNlIiwiY29kZUZlbmNlZCIsImNvZGVGbG93IiwiY29kZUZlbmNlZEZlbmNlSW5mbyIsImJ1ZmZlciIsImNvZGVGZW5jZWRGZW5jZU1ldGEiLCJjb2RlSW5kZW50ZWQiLCJjb2RlVGV4dCIsImNvZGVUZXh0RGF0YSIsImRhdGEiLCJjb2RlRmxvd1ZhbHVlIiwiZGVmaW5pdGlvbiIsImRlZmluaXRpb25EZXN0aW5hdGlvblN0cmluZyIsImRlZmluaXRpb25MYWJlbFN0cmluZyIsImRlZmluaXRpb25UaXRsZVN0cmluZyIsImVtcGhhc2lzIiwiaGFyZEJyZWFrRXNjYXBlIiwiaGFyZEJyZWFrIiwiaGFyZEJyZWFrVHJhaWxpbmciLCJodG1sRmxvdyIsImh0bWwiLCJodG1sRmxvd0RhdGEiLCJodG1sVGV4dCIsImh0bWxUZXh0RGF0YSIsImltYWdlIiwibGFiZWwiLCJsaXN0SXRlbSIsImxpc3RJdGVtVmFsdWUiLCJvbmVudGVybGlzdGl0ZW12YWx1ZSIsImxpc3RPcmRlcmVkIiwibGlzdCIsIm9uZW50ZXJsaXN0b3JkZXJlZCIsImxpc3RVbm9yZGVyZWQiLCJwYXJhZ3JhcGgiLCJyZWZlcmVuY2UiLCJvbmVudGVycmVmZXJlbmNlIiwicmVmZXJlbmNlU3RyaW5nIiwicmVzb3VyY2VEZXN0aW5hdGlvblN0cmluZyIsInJlc291cmNlVGl0bGVTdHJpbmciLCJzZXRleHRIZWFkaW5nIiwic3Ryb25nIiwidGhlbWF0aWNCcmVhayIsImV4aXQiLCJjbG9zZXIiLCJhdHhIZWFkaW5nU2VxdWVuY2UiLCJvbmV4aXRhdHhoZWFkaW5nc2VxdWVuY2UiLCJvbmV4aXRhdXRvbGlua2VtYWlsIiwib25leGl0YXV0b2xpbmtwcm90b2NvbCIsImNoYXJhY3RlckVzY2FwZVZhbHVlIiwib25leGl0ZGF0YSIsImNoYXJhY3RlclJlZmVyZW5jZU1hcmtlckhleGFkZWNpbWFsIiwib25leGl0Y2hhcmFjdGVycmVmZXJlbmNlbWFya2VyIiwiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyTnVtZXJpYyIsImNoYXJhY3RlclJlZmVyZW5jZVZhbHVlIiwib25leGl0Y2hhcmFjdGVycmVmZXJlbmNldmFsdWUiLCJvbmV4aXRjb2RlZmVuY2VkIiwiY29kZUZlbmNlZEZlbmNlIiwib25leGl0Y29kZWZlbmNlZGZlbmNlIiwib25leGl0Y29kZWZlbmNlZGZlbmNlaW5mbyIsIm9uZXhpdGNvZGVmZW5jZWRmZW5jZW1ldGEiLCJvbmV4aXRjb2RlaW5kZW50ZWQiLCJvbmV4aXRjb2RldGV4dCIsIm9uZXhpdGRlZmluaXRpb25kZXN0aW5hdGlvbnN0cmluZyIsIm9uZXhpdGRlZmluaXRpb25sYWJlbHN0cmluZyIsIm9uZXhpdGRlZmluaXRpb250aXRsZXN0cmluZyIsIm9uZXhpdGhhcmRicmVhayIsIm9uZXhpdGh0bWxmbG93Iiwib25leGl0aHRtbHRleHQiLCJvbmV4aXRpbWFnZSIsIm9uZXhpdGxhYmVsIiwibGFiZWxUZXh0Iiwib25leGl0bGFiZWx0ZXh0IiwibGluZUVuZGluZyIsIm9uZXhpdGxpbmVlbmRpbmciLCJvbmV4aXRsaW5rIiwib25leGl0cmVmZXJlbmNlc3RyaW5nIiwib25leGl0cmVzb3VyY2VkZXN0aW5hdGlvbnN0cmluZyIsIm9uZXhpdHJlc291cmNldGl0bGVzdHJpbmciLCJyZXNvdXJjZSIsIm9uZXhpdHJlc291cmNlIiwib25leGl0c2V0ZXh0aGVhZGluZyIsInNldGV4dEhlYWRpbmdMaW5lU2VxdWVuY2UiLCJvbmV4aXRzZXRleHRoZWFkaW5nbGluZXNlcXVlbmNlIiwic2V0ZXh0SGVhZGluZ1RleHQiLCJvbmV4aXRzZXRleHRoZWFkaW5ndGV4dCIsImNvbmZpZ3VyZSIsIm1kYXN0RXh0ZW5zaW9ucyIsImNvbXBpbGUiLCJldmVudHMiLCJ0cmVlIiwidHlwZSIsImNoaWxkcmVuIiwiY29udGV4dCIsInN0YWNrIiwidG9rZW5TdGFjayIsInJlc3VtZSIsImxpc3RTdGFjayIsImluZGV4IiwibGVuZ3RoIiwicHVzaCIsInRhaWwiLCJwb3AiLCJwcmVwYXJlTGlzdCIsImhhbmRsZXIiLCJjYWxsIiwiT2JqZWN0IiwiYXNzaWduIiwic2xpY2VTZXJpYWxpemUiLCJkZWZhdWx0T25FcnJvciIsInBvc2l0aW9uIiwic3RhcnQiLCJwb2ludCIsImxpbmUiLCJjb2x1bW4iLCJvZmZzZXQiLCJlbmQiLCJjb250YWluZXJCYWxhbmNlIiwibGlzdFNwcmVhZCIsImxpbmVJbmRleCIsImZpcnN0QmxhbmtMaW5lSW5kZXgiLCJhdE1hcmtlciIsImV2ZW50IiwibGluZUVuZGluZ0JsYW5rIiwibGluZVByZWZpeCIsImxpc3RJdGVtTWFya2VyIiwibGlzdEl0ZW1QcmVmaXgiLCJsaXN0SXRlbVByZWZpeFdoaXRlc3BhY2UiLCJ0YWlsSW5kZXgiLCJ0YWlsRXZlbnQiLCJibG9ja1F1b3RlUHJlZml4IiwiYmxvY2tRdW90ZVByZWZpeFdoaXRlc3BhY2UiLCJibG9ja1F1b3RlTWFya2VyIiwibGlzdEl0ZW1JbmRlbnQiLCJfc3ByZWFkIiwic3BsaWNlIiwiaXRlbSIsImNyZWF0ZSIsImFuZCIsIm9wZW4iLCJ0b2tlbiIsIm5vZGUiLCJlcnJvckhhbmRsZXIiLCJwYXJlbnQiLCJzaWJsaW5ncyIsImNsb3NlIiwib25FeGl0RXJyb3IiLCJFcnJvciIsImV4cGVjdGluZ0ZpcnN0TGlzdEl0ZW1WYWx1ZSIsImFuY2VzdG9yIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJudW1lcmljQmFzZURlY2ltYWwiLCJsYW5nIiwibWV0YSIsImZsb3dDb2RlSW5zaWRlIiwicmVwbGFjZSIsImlkZW50aWZpZXIiLCJ0b0xvd2VyQ2FzZSIsInRpdGxlIiwidXJsIiwiZGVwdGgiLCJzZXRleHRIZWFkaW5nU2x1cnBMaW5lRW5kaW5nIiwiY29kZVBvaW50QXQiLCJlcXVhbHNUbyIsInRleHQiLCJhdEhhcmRCcmVhayIsImluY2x1ZGVzIiwiaW5SZWZlcmVuY2UiLCJyZWZlcmVuY2VUeXBlIiwic3RyaW5nIiwiZnJhZ21lbnQiLCJhbHQiLCJjaGFyYWN0ZXJSZWZlcmVuY2VUeXBlIiwibnVtZXJpY0Jhc2VIZXhhZGVjaW1hbCIsInJlc3VsdCIsIm9yZGVyZWQiLCJzcHJlYWQiLCJjaGVja2VkIiwiZCIsImNvbWJpbmVkIiwiZXh0ZW5zaW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImV4dGVuc2lvbiIsImtleSIsInJpZ2h0IiwibGVmdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mdast-util-from-markdown/dev/lib/index.js\n");

/***/ })

};
;